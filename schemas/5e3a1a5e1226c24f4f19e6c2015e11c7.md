---
title: 5e3a1a5e1226c24f4f19e6c2015e11c7
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/5e3a1a5e1226c24f4f19e6c2015e11c7.xml
---

# 5e3a1a5e1226c24f4f19e6c2015e11c7

This XML file defines the schema for various game components and their associated variables within the game Noita. It acts as a blueprint, detailing the structure and types of data that can be used to configure game entities, behaviors, and properties. This schema is crucial for the game's internal workings, allowing it to load, interpret, and utilize data for everything from enemy AI to visual elements. Modders can use this file to understand how to structure their own custom game data.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct type of game component. Each `<Component>` has a `component_name` attribute that uniquely identifies it. Inside each `<Component>`, there are `<Var>` elements, which define individual variables associated with that component.

Each `<Var>` element has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<float>` (representing a 2D vector of floats).

The structure is hierarchical:
```xml
<Schema hash="...">
  <Component component_name="...">
    <Var name="..." size="..." type="...">
    </Var>
    <Var name="..." size="..." type="...">
    </Var>
    ...
  </Component>
  <Component component_name="...">
    ...
  </Component>
  ...
</Schema>
```

## Key Patterns

*   **Component-Based Design:** The game appears to use a component-based architecture, where entities are composed of various functional components. This file defines the data structure for these components.
*   **Variable Types:** A wide range of data types are supported, from simple integers and booleans to complex string representations and custom vector types. This allows for detailed configuration of component behavior.
*   **Naming Conventions:** Variable names are generally descriptive, indicating their purpose (e.g., `use_probability`, `min_distance`, `animation_name`).
*   **String Representation:** C++ standard library string types are explicitly defined, indicating how text data is handled.
*   **Vector Types:** Custom vector types (e.g., `ceng::math::CVector2<float>`) are used for representing spatial data like positions and velocities.
*   **Boolean Flags:** Many variables are booleans (`type="bool"`) used to enable or disable specific features or behaviors.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`:**
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      ...
    </Component>
    ```
    This component likely defines the parameters for an AI's attack behavior. It includes variables for attack range, probabilities, animation sequences, and the specific entity files to be used for ranged attacks.

2.  **`AIComponent`:**
    ```xml
    <Component component_name="AIComponent" >
      <Var name="mouse_look" size="1" type="bool" >
      </Var>
      <Var name="keyboard_look" size="1" type="bool" >
      </Var>
      <Var name="animation_to_play" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      ...
    </Component>
    ```
    This component seems to govern general AI behavior, including how the AI perceives and reacts to input (mouse/keyboard look) and which animations it should play.

3.  **`PixelSpriteComponent`:**
    ```xml
    <Component component_name="PixelSpriteComponent" >
      <Var name="image_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="anchor_x" size="4" type="int" >
      </Var>
      <Var name="anchor_y" size="4" type="int" >
      </Var>
      <Var name="material" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="diggable" size="1" type="bool" >
      </Var>
      ...
    </Component>
    ```
    This component is responsible for the visual representation of entities. It defines the image file to be used, its anchor points, material properties, and whether it can be dug.

## Reference

This file contains 6632 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/5e3a1a5e1226c24f4f19e6c2015e11c7.xml).

---