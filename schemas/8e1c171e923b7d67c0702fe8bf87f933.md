---
title: 8e1c171e923b7d67c0702fe8bf87f933
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/8e1c171e923b7d67c0702fe8bf87f933.xml
---

# 8e1c171e923b7d67c0702fe8bf87f933

This XML file, identified by the hash `8e1c171e923b7d67c0702fe8bf87f933`, defines the schema for various game components in Noita. It acts as a blueprint, specifying the structure and data types for different aspects of game entities, such as their AI behaviors, physical properties, and visual elements. This schema file is crucial for the game's engine to correctly interpret and utilize the data associated with each component, enabling the creation of diverse and complex game mechanics.

## File Structure

The file is structured as an XML document with a root `<Schema>` element. Inside the `<Schema>` element, various `<Component>` elements are defined. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute that identifies it.

Within each `<Component>`, there are multiple `<Var>` elements. These `<Var>` elements define individual variables or properties associated with that component. Each `<Var>` element has the following attributes:

*   **`name`**: The name of the variable.
*   **`size`**: The size of the variable in bytes. This can indicate the data type's memory footprint.
*   **`type`**: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or custom struct types like `struct LensValue<float>`.

The structure is hierarchical: `Schema` -> `Component` -> `Var`.

## Key Patterns

*   **Component-Based Design**: The file clearly follows a component-based architecture, where different functionalities are encapsulated into distinct components (e.g., `AIAttackComponent`, `AIComponent`, `PathFindingComponent`).
*   **Variable Definitions**: Each component's properties are defined using `<Var>` tags, specifying their names, sizes, and data types. This allows for granular control over the data associated with each component.
*   **Data Type Variety**: The file showcases a range of data types, from simple booleans and integers to floats and complex string representations, indicating the diverse nature of game data.
*   **Physical and Behavioral Properties**: Components like `AIComponent` and `PathFindingComponent` define parameters related to entity behavior, movement, and decision-making. Other components, like those related to collision or physics (implied by `mass`, `gravity`, `buoyancy_check_offset_y`), define physical attributes.
*   **String Representation**: The use of `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` for string types suggests that these are likely used for names, file paths, or other textual data within the game.
*   **Custom Structs**: The presence of `struct LensValue<float>` indicates that custom data structures are used to represent certain values, potentially offering more complex data handling or serialization.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**:
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
    </Component>
    ```
    This component defines parameters for an AI's attack capabilities. It includes variables for attack probability, range, animation names, and the entity file used for ranged attacks.

2.  **`AIComponent` (partial)**:
    ```xml
    <Component component_name="AIComponent" >
      <Var name="platforming_type" size="4" type="int" >
      </Var>
      <Var name="collision_aabb_min_x" size="12" type="struct LensValue<float>" >
      </Var>
      <Var name="gravity" size="4" type="float" >
      </Var>
      <Var name="flying_needs_recharge" size="1" type="bool" >
    </Component>
    ```
    This component appears to define general AI behaviors, including platforming preferences, collision bounding box limits, gravity influence, and whether flying requires recharging.

3.  **`PathFindingComponent`**:
    ```xml
    <Component component_name="PathFindingComponent" >
      <Var name="search_depth_max_no_goal" size="4" type="int" >
      </Var>
      <Var name="cost_of_flying" size="4" type="float" >
      </Var>
      <Var name="frames_between_searches" size="4" type="int" >
      </Var>
      <Var name="can_fly" size="1" type="bool" >
    </Component>
    ```
    This component details the pathfinding logic for entities. It includes parameters for search depth, movement costs (like flying), search frequency, and whether the entity is capable of flight.

## Reference

This file contains 6576 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/8e1c171e923b7d67c0702fe8bf87f933.xml).

---