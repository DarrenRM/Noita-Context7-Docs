---
title: 9d614a242dd74caf806722dad269d92e
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/9d614a242dd74caf806722dad269d92e.xml
---

# 9d614a242dd74caf806722dad269d92e

This XML file defines the data schema for various components used within the game Noita. It acts as a blueprint, specifying the structure and types of data that each game component can hold. These components are fundamental building blocks for entities in the game, dictating their behavior, properties, and interactions. Understanding this schema is crucial for analyzing game data, and for modders looking to create or modify game entities.

## File Structure

The file is structured as a series of `<Component>` elements, each representing a distinct type of game component. Within each `<Component>`, there are `<Var>` elements that define individual data variables.

*   **`<Schema>`:** The root element, containing a `hash` attribute that uniquely identifies this schema.
*   **`<Component>`:** Represents a specific game component. It has a `component_name` attribute that names the component (e.g., "AIAttackComponent", "AIComponent").
*   **`<Var>`:** Defines a single data variable within a component. Each `<Var>` element has the following attributes:
    *   `name`: The name of the variable (e.g., "use_probability", "min_distance").
    *   `size`: The size of the variable in bytes.
    *   `type`: The data type of the variable (e.g., "int", "float", "bool", "class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" which represents a string).

The structure is hierarchical, with `<Var>` elements nested within `<Component>` elements.

## Key Patterns

*   **Component-Based Design:** The file clearly illustrates Noita's component-based entity system, where different functionalities are encapsulated in distinct components.
*   **Variable Definitions:** Each `<Var>` specifies not just the name and type, but also the memory `size`, which can be indicative of how the data is stored or processed.
*   **Data Types:** A variety of data types are used, including primitive types like integers (`int`), floating-point numbers (`float`), and booleans (`bool`), as well as more complex types like strings (represented by `std::basic_string`).
*   **AI and Physics Focus:** The sampled components ("AIAttackComponent", "AIComponent", "ElectricityReceiverComponent", "PhysicsJointComponent") suggest a strong focus on defining AI behaviors, electrical interactions, and physics properties for game entities.
*   **Naming Conventions:** Variable names are descriptive, often indicating their purpose (e.g., `attack_ranged_enabled`, `motor_max_torque`, `splittings_min`).

## Sample Entries

Here are a few representative examples from the sampled content:

**1. AIAttackComponent Variables:**
```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="angular_range_deg" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```
This snippet defines variables for an AI attack component. It includes parameters like the probability of using an attack (`use_probability`), the range of the attack (`min_distance`, `max_distance`), the angular spread (`angular_range_deg`), and the name of the animation associated with the attack (`animation_name`).

**2. AIComponent Attack Flags:**
```xml
    <Var name="attack_melee_enabled" size="1" type="bool" >
    </Var>

    <Var name="attack_dash_enabled" size="1" type="bool" >
    </Var>

    <Var name="attack_landing_ranged_enabled" size="1" type="bool" >
    </Var>

    <Var name="attack_ranged_enabled" size="1" type="bool" >
    </Var>
```
This section from the `AIComponent` shows boolean flags that enable or disable different types of attacks for an AI entity, such as melee, dash, and ranged attacks.

**3. PhysicsJointComponent Properties:**
```xml
  <Component component_name="PhysicsJointComponent" >

    <Var name="nail_to_wall" size="1" type="bool" >
    </Var>

    <Var name="grid_joint" size="1" type="bool" >
    </Var>

    <Var name="breakable" size="1" type="bool" >
    </Var>

    <Var name="type" size="4" type="enum JOINT_TYPE::Enum" >
    </Var>

    <Var name="body1_id" size="4" type="int" >
    </Var>

    <Var name="body2_id" size="4" type="int" >
    </Var>

    <Var name="pos_x" size="4" type="float" >
    </Var>

    <Var name="pos_y" size="4" type="float" >
    </Var>
```
This defines properties for a physics joint. It includes boolean flags for whether the joint nails to a wall (`nail_to_wall`), is a grid joint (`grid_joint`), or is breakable (`breakable`). It also specifies the type of joint (`type`) and the IDs of the two bodies it connects (`body1_id`, `body2_id`), along with its position.

## Reference

This file contains 6928 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/9d614a242dd74caf806722dad269d92e.xml).

---