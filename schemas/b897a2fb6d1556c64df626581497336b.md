---
title: b897a2fb6d1556c64df626581497336b
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/b897a2fb6d1556c64df626581497336b.xml
---

# b897a2fb6d1556c64df626581497336b

This XML file defines the schema for various game components in Noita. It acts as a blueprint, outlining the structure and data types for different aspects of game entities, such as AI behaviors, physics properties, and visual elements. By defining these components, the game can consistently load, interpret, and utilize data for entities, ensuring predictable behavior and appearance across different game objects. This schema file is crucial for understanding how game data is organized and for modding purposes, as it dictates the available parameters for customization.

## File Structure

The file is structured as an XML document with a root `<Schema>` element. Inside the `<Schema>` element, various `<Component>` elements are defined. Each `<Component>` represents a distinct set of properties and behaviors that can be attached to game entities.

Within each `<Component>`, individual properties are defined using `<Var>` elements. These `<Var>` elements specify:

*   **`name`**: The identifier for the variable (e.g., `use_probability`, `attack_ranged_enabled`).
*   **`size`**: The size of the data in bytes.
*   **`type`**: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` which represents a string, `enum RAGDOLL_FX::Enum`, `struct ceng::math::CXForm<float>`, `class ceng::math::CVector2<float>`).

The structure is hierarchical: `Schema` contains `Component`s, and `Component`s contain `Var`s.

## Key Patterns

Several patterns are evident in the sampled data:

*   **Component-Based Design**: The game utilizes a component-based architecture, where entities are composed of various functional components. This file defines the structure of these components.
*   **AI Components**: A significant portion of the file appears to define AI-related behaviors. This includes parameters for attacking (`AIAttackComponent`, `AIComponent`), movement, and other decision-making processes.
*   **Physics Components**: Components related to physics, such as `PhysicsPickUpComponent` and `PhysicsShapeComponent`, define how entities interact with the game's physics engine, including properties like pick-up strength and shape characteristics.
*   **Data Types**: A mix of fundamental C++ data types (`int`, `float`, `bool`) and more complex types (strings, enums, custom structs/classes like `ceng::math::CVector2<float>`) are used, reflecting the underlying game engine.
*   **Naming Conventions**: Variable names are generally descriptive, often prefixed with the component they belong to (e.g., `attack_ranged_enabled`, `ragdoll_effect`).

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
<Component component_name="AIAttackComponent" >
  <Var name="use_probability" size="4" type="int" >
  </Var>
  <Var name="min_distance" size="4" type="float" >
  </Var>
  <Var name="max_distance" size="4" type="float" >
  </Var>
  <Var name="angular_range_deg" size="4" type="float" >
  </Var>
  <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
  <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
</Component>
```

This section defines parameters for an AI's attack capabilities. It includes variables for the probability of using an attack, the range (minimum and maximum distance), the angular spread of the attack, the name of the animation associated with the attack, and the entity file to be spawned for ranged attacks.

**2. `AIComponent` Attack Variables:**

```xml
<Component component_name="AIComponent" >
  <Var name="attack_landing_ranged_enabled" size="1" type="bool" >
  </Var>
  <Var name="attack_ranged_enabled" size="1" type="bool" >
  </Var>
  <Var name="attack_melee_damage_min" size="4" type="float" >
  </Var>
  <Var name="attack_melee_damage_max" size="4" type="float" >
  </Var>
  <Var name="attack_melee_impulse_vector_x" size="4" type="float" >
  </Var>
</Component>
```

This snippet from the `AIComponent` shows more attack-related variables, specifically for both ranged and melee attacks. It includes boolean flags to enable these attack types, and for melee attacks, it defines the minimum and maximum damage, as well as the impulse vector (direction and magnitude) applied by the attack.

**3. `PhysicsPickUpComponent` Variables:**

```xml
<Component component_name="PhysicsPickUpComponent" >
  <Var name="transform" size="32" type="struct ceng::math::CXForm<float>" >
  </Var>
  <Var name="original_left_joint_pos" size="8" type="class ceng::math::CVector2<float>" >
  </Var>
  <Var name="pick_up_strength" size="4" type="float" >
  </Var>
</Component>
```

This component defines properties related to an entity's ability to be picked up or to pick up other entities. It includes a `transform` for its position and orientation, joint positions for interaction points, and `pick_up_strength`, which likely dictates how easily it can be manipulated by physics.

## Reference

This file contains 6788 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/b897a2fb6d1556c64df626581497336b.xml).

---