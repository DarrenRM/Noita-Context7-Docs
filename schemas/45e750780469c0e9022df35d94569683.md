---
title: 45e750780469c0e9022df35d94569683
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/45e750780469c0e9022df35d94569683.xml
---

# 45e750780469c0e9022df35d94569683

This XML file defines the structure and properties of various game components used in Noita. It acts as a schema or blueprint, detailing the data fields associated with different game entities and their behaviors. These components are fundamental to how objects, enemies, and environmental elements function within the game world, dictating aspects like AI behavior, damage mechanics, visual effects, and more. Understanding this schema is crucial for anyone looking to modify or deeply analyze Noita's game mechanics.

## File Structure

The file is structured as an XML document, with a root `<Schema>` tag. Inside this root tag, individual game components are defined using `<Component>` tags. Each `<Component>` tag has a `component_name` attribute that identifies the specific type of component it describes.

Within each `<Component>`, the individual data fields are defined using `<Var>` tags. These `<Var>` tags have several important attributes:

*   **`name`**: The name of the variable or property within the component.
*   **`size`**: The size of the data in bytes. This can give clues about the data type.
*   **`type`**: The data type of the variable. This can range from basic types like `int`, `float`, and `bool` to more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or custom game classes like `ceng::math::CVector2<float>` and `ConfigExplosion`.

The structure is hierarchical: `<Schema>` contains multiple `<Component>`s, and each `<Component>` contains multiple `<Var>`s.

## Key Patterns

*   **Component-Based Design**: The file clearly demonstrates a component-based architecture, where different functionalities are encapsulated into distinct components (e.g., `AIAttackComponent`, `AreaDamageComponent`, `LightningComponent`).
*   **Variable Definitions**: Each component's properties are defined as variables (`<Var>`) with explicit names, sizes, and types. This allows for precise control over game data.
*   **Data Types**: A variety of data types are used, including primitive types (`int`, `float`, `bool`), string types, vector types (for positions, sizes, etc.), and custom class types that likely represent more complex game objects or configurations.
*   **Enum Usage**: Some `type` attributes indicate `enum`s (e.g., `enum ARC_TYPE::Enum`, `enum DAMAGE_TYPES::Enum`), suggesting that certain variables hold values from predefined sets of constants.
*   **Class Pointers**: The presence of types like `class PixelSprite *` indicates that components can hold references to other game objects.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**:
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
    </Component>
    ```
    This component defines parameters for an AI's attack behavior. It includes variables for attack probability, range (`min_distance`, `max_distance`), aiming angles (`angular_range_deg`), associated animations (`animation_name`), and the entity file to spawn for ranged attacks (`attack_ranged_entity_file`).

2.  **`AreaDamageComponent`**:
    ```xml
    <Component component_name="AreaDamageComponent" >
      <Var name="aabb_min" size="8" type="class ceng::math::CVector2<float>" >
      </Var>
      <Var name="aabb_max" size="8" type="class ceng::math::CVector2<float>" >
      </Var>
      <Var name="damage_type" size="4" type="enum DAMAGE_TYPES::Enum" >
      </Var>
      <Var name="damage_per_frame" size="4" type="float" >
      </Var>
      <Var name="death_cause" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
    </Component>
    ```
    This component defines an area of effect that deals damage. It specifies the bounding box of the area (`aabb_min`, `aabb_max`), the type of damage dealt (`damage_type`), the amount of damage per frame (`damage_per_frame`), and the cause of death string (`death_cause`).

3.  **`LightningComponent`**:
    ```xml
    <Component component_name="LightningComponent" >
      <Var name="config_explosion" size="356" type="class ConfigExplosion" >
      </Var>
      <Var name="sprite_lightning_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="is_projectile" size="1" type="bool" >
      </Var>
      <Var name="arc_lifetime" size="4" type="int" >
      </Var>
    </Component>
    ```
    This component likely governs lightning-based effects. It includes a reference to an explosion configuration (`config_explosion`), the sprite file for the lightning effect (`sprite_lightning_file`), a flag indicating if it's a projectile (`is_projectile`), and the lifetime of the lightning arcs (`arc_lifetime`).

## Reference

This file contains 6196 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/45e750780469c0e9022df35d94569683.xml).

---