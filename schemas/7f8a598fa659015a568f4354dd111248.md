---
title: 7f8a598fa659015a568f4354dd111248
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/7f8a598fa659015a568f4354dd111248.xml
---

# 7f8a598fa659015a568f4354dd111248

This XML file defines the structure and properties of various game components within Noita. These components are fundamental building blocks that dictate the behavior, appearance, and functionality of entities in the game, such as enemies, items, and environmental elements. By defining these components and their associated variables, the game engine can instantiate and manage complex game objects with specific attributes. This file acts as a schema, outlining the expected data for each component type.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute to identify it.

Within each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual properties or variables associated with that component. Each `<Var>` has the following attributes:

*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, `class ceng::math::CVector2<int>`).

The `type` attribute often includes C++ class names, indicating the underlying data structures used by the game engine. For string types, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` is common, and for 2D vectors of integers, `class ceng::math::CVector2<int>` is used.

## Key Patterns

*   **Component-Based Architecture:** The file clearly demonstrates a component-based design pattern, where game entities are composed of various independent components, each responsible for a specific aspect of functionality.
*   **Variable Definitions:** Each component is defined by a set of variables, specifying its configurable parameters. These variables cover a wide range of game mechanics, from AI behavior and physics to inventory management and visual properties.
*   **Data Types:** A variety of data types are used, including primitive types like integers, floats, and booleans, as well as more complex C++ class types for strings and vector math.
*   **AI and Behavior:** Several components appear to be related to Artificial Intelligence and entity behavior, such as `AIAttackComponent` and `AIComponent`, defining attack parameters, movement, and decision-making.
*   **Inventory and Items:** Components like `InventoryComponent` and `ItemAIKnowledgeComponent` suggest definitions related to player inventory, item properties, and how items interact with AI.
*   **Physics and Damage:** Variables related to physics, such as `falling_damage_damage_min` and `physics_objects_damage`, indicate how entities interact with the physical environment and take damage.
*   **Scripting Hooks:** Some components, like `ScriptComponent`, define variables that likely serve as hooks for custom scripting, allowing for dynamic behavior modification.

## Sample Entries

**1. AIAttackComponent:**
This component defines parameters related to an entity's attack capabilities.

```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="state_duration_frames" size="4" type="int" >
    </Var>
    <Var name="frames_between" size="4" type="int" >
    </Var>
    <Var name="frames_between_global" size="4" type="int" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_count_min" size="4" type="int" >
    </Var>
    <Var name="attack_ranged_entity_count_max" size="4" type="int" >
    </Var>
  </Component>
```
This sample shows variables like `use_probability`, `min_distance`, `max_distance`, and `angular_range_deg` which control the likelihood and range of an attack. `animation_name` suggests that specific animations are tied to attacks, and `attack_ranged_entity_file` indicates that ranged attacks can spawn other entities.

**2. AIComponent (partial):**
This component appears to define general AI properties, including how an entity interacts with its environment regarding damage and air.

```xml
    <Var name="falling_damage_damage_min" size="4" type="float" >
    </Var>
    <Var name="falling_damage_damage_max" size="4" type="float" >
    </Var>
    <Var name="air_needed" size="1" type="bool" >
    </Var>
    <Var name="air_in_lungs" size="4" type="float" >
    </Var>
    <Var name="air_in_lungs_max" size="4" type="float" >
    </Var>
    <Var name="air_lack_of_damage" size="4" type="float" >
    </Var>
    <Var name="materials_damage" size="1" type="bool" >
    </Var>
    <Var name="materials_that_damage" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="materials_how_much_damage" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```
Here, `falling_damage_damage_min` and `falling_damage_damage_max` define the range of damage from falling. `air_needed`, `air_in_lungs`, and `air_lack_of_damage` suggest mechanics related to breathing and suffocation. `materials_damage`, `materials_that_damage`, and `materials_how_much_damage` indicate that certain materials can cause damage to entities.

**3. ScriptComponent (partial):**
This component seems to be a central hub for defining script-based behaviors triggered by various game events.

```xml
    <Var name="script_ingested_material" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_death" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_throw_item" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_material_area_checker_failed" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_kick" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_interacting" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_audio_event_dead" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```
This sample shows variables like `script_death`, `script_throw_item`, and `script_kick`. The naming convention strongly suggests that these variables hold references to Lua scripts that are executed when the corresponding event occurs (e.g., when an entity dies, throws an item, or is kicked).

## Reference

This file contains 6300 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/7f8a598fa659015a568f4354dd111248.xml).
---