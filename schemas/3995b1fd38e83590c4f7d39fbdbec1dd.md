---
title: 3995b1fd38e83590c4f7d39fbdbec1dd
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/3995b1fd38e83590c4f7d39fbdbec1dd.xml
---

# 3995b1fd38e83590c4f7d39fbdbec1dd

This file defines the structure and properties of various game components used within Noita. These components dictate the behavior, appearance, and interactions of entities in the game world. The file acts as a schema, outlining the types of data and their organization for each component, allowing the game engine to load and interpret entity definitions. It's a fundamental part of Noita's data-driven design, enabling complex entity behaviors to be defined and modified.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute. Inside each `<Component>`, there are `<Var>` elements, each defining a variable or property of that component.

Each `<Var>` element has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This often includes C++ type names like `int`, `float`, `bool`, and `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string).

The structure is hierarchical:
```xml
<Schema>
  <Component component_name="ComponentName">
    <Var name="variableName1" size="X" type="dataType1">
      <!-- Optional content, often empty for simple types -->
    </Var>
    <Var name="variableName2" size="Y" type="dataType2">
      <!-- ... -->
    </Var>
    <!-- ... more Var elements -->
  </Component>
  <!-- ... more Component elements -->
</Schema>
```

## Key Patterns

*   **Component-Based Design:** The file clearly follows a component-based architecture, where different functionalities are encapsulated into distinct components. This is evident from the `<Component>` tags, each with a unique `component_name`.
*   **Variable Definitions:** Each component's properties are defined using `<Var>` tags, specifying the name, size, and data type. This allows for granular control over entity attributes.
*   **Data Types:** A variety of data types are used, including primitive types (`int`, `float`, `bool`) and complex types like strings (`class std::basic_string<...>`). The presence of C++ type names suggests the underlying game engine's implementation.
*   **Categorization by Functionality:** Components appear to be grouped by their functional role in the game. For example, `AIAttackComponent` deals with combat AI, `CollisionTriggerComponent` handles collision events, and `MagicConvertMaterialComponent` manages material transformations.
*   **Configuration Parameters:** The variables within components represent configurable parameters. For instance, `AIAttackComponent` has variables like `use_probability`, `min_distance`, and `animation_name`, which directly influence how an AI attacks.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`:**
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <!-- ... other attack-related variables -->
    </Component>
    ```
    This component defines parameters for an AI's attack behavior, including probabilities, distances, angles, animation names, and the entity files used for ranged attacks.

2.  **`CollisionTriggerComponent`:**
    ```xml
    <Component component_name="CollisionTriggerComponent" >
      <Var name="width" size="4" type="float" >
      </Var>
      <Var name="height" size="4" type="float" >
      </Var>
      <Var name="radius" size="4" type="float" >
      </Var>
      <Var name="required_tag" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="remove_component_when_triggered" size="1" type="bool" >
      </Var>
      <Var name="destroy_this_entity_when_triggered" size="1" type="bool" >
      </Var>
      <!-- ... other trigger-related variables -->
    </Component>
    ```
    This component defines a trigger area based on dimensions (width, height, radius) and a required tag. It also specifies actions to take when triggered, such as removing the component or destroying the entity.

3.  **`MagicConvertMaterialComponent`:**
    ```xml
    <Component component_name="MagicConvertMaterialComponent" >
      <Var name="radius" size="4" type="int" >
      </Var>
      <Var name="is_circle" size="1" type="bool" >
      </Var>
      <Var name="steps_per_frame" size="4" type="int" >
      </Var>
      <Var name="from_material" size="4" type="int" >
      </Var>
      <Var name="from_material_tag" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="to_material" size="4" type="int" >
      </Var>
      <Var name="clean_stains" size="1" type="bool" >
      </Var>
      <!-- ... other material conversion variables -->
    </Component>
    ```
    This component is responsible for converting one material into another within a specified radius. It includes parameters for the conversion area shape, conversion speed, the materials involved, and whether to clean stains or extinguish fire.

## Reference

This file contains 6264 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/3995b1fd38e83590c4f7d39fbdbec1dd.xml).

---