---
title: 4031555c1d1c131c3070b7c1789a4e40
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/4031555c1d1c131c3070b7c1789a4e40.xml
---

# 4031555c1d1c131c3070b7c1789a4e40

This XML file defines the schema for various game components and their properties within Noita. It acts as a blueprint, outlining the structure and data types for different aspects of game entities, such as AI behavior, physics, and item properties. This schema is crucial for the game engine to correctly interpret and utilize the data associated with these components, enabling the creation of diverse and complex game elements.

## File Structure

The file is structured as an XML document, with a root `<Schema>` element. Inside this, various `<Component>` elements are defined. Each `<Component>` represents a distinct set of properties and behaviors that can be attached to game entities.

Within each `<Component>`, individual properties are defined using `<Var>` tags. These `<Var>` tags specify:
*   `name`: The identifier for the variable (e.g., `use_probability`, `velocity_min_x`).
*   `size`: The memory size allocated for this variable.
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, `struct LensValue<float>`, `class ceng::math::CVector2<float>`).

The structure is hierarchical, with the schema containing components, and components containing variables.

**Example Structure:**

```xml
<Schema hash="...">
  <Component component_name="...">
    <Var name="..." size="..." type="...">
    </Var>
    <Var name="..." size="..." type="...">
    </Var>
    ...
  </Component>
  <Component component_name="...">
    ...
  </Component>
  ...
</Schema>
```

## Key Patterns

Several patterns emerge from the sampled content:

*   **Component-Based Design:** The game appears to use a component-based architecture, where entities are composed of various functional components. This file defines the structure of these components.
*   **Variable Naming Conventions:** Variable names are descriptive, often indicating the purpose or context of the data (e.g., `attack_ranged_offset_x`, `eff_hg_velocity_min_y`, `is_frozen`).
*   **Data Type Variety:** A range of data types are used, including primitive types (`int`, `float`, `bool`) and more complex C++ types (e.g., `std::basic_string`, `LensValue`, `CVector2`), indicating sophisticated data handling.
*   **AI and Physics Focus:** The samples highlight components related to AI behavior (`AIAttackComponent`, `AIComponent`) and physics (`CharacterPlatformingComponent`, `PhysicsBodyComponent`), suggesting these are core areas of definition.
*   **Configuration Parameters:** Many variables appear to be configuration parameters for tuning game mechanics, such as attack ranges, velocities, and visual effects.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**
This component seems to define the parameters for an AI's attack capabilities.

```xml
<Component component_name="AIAttackComponent" >
  <Var name="use_probability" size="4" type="int" >
  </Var>
  <Var name="min_distance" size="4" type="float" >
  </Var>
  <Var name="max_distance" size="4" type="float" >
  </Var>
  <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
  <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
  ...
</Component>
```
*   `use_probability`: Likely controls how often this attack is used.
*   `min_distance`, `max_distance`: Define the effective range of the attack.
*   `animation_name`: Specifies the animation to play when attacking.
*   `attack_ranged_entity_file`: Points to the entity file (e.g., projectile) used for ranged attacks.

**2. `CharacterPlatformingComponent` Variables:**
This component appears to govern the movement and platforming abilities of characters.

```xml
<Component component_name="CharacterPlatformingComponent" >
  <Var name="velocity_min_x" size="12" type="struct LensValue<float>" >
  </Var>
  <Var name="velocity_max_x" size="12" type="struct LensValue<float>" >
  </Var>
  <Var name="velocity_min_y" size="12" type="struct LensValue<float>" >
  </Var>
  ...
</Component>
```
*   `velocity_min_x`, `velocity_max_x`, `velocity_min_y`: These likely define the minimum and maximum velocities in the X and Y directions, possibly with complex behavior defined by `struct LensValue<float>`.

**3. `PhysicsBodyComponent` Variables:**
This component defines the physical properties of an entity.

```xml
<Component component_name="PhysicsBodyComponent" >
  <Var name="is_external" size="1" type="bool" >
  </Var>
  <Var name="hax_fix_going_through_ground" size="1" type="bool" >
  </Var>
  <Var name="linear_damping" size="4" type="float" >
  </Var>
  <Var name="angular_damping" size="4" type="float" >
  </Var>
  ...
</Component>
```
*   `is_external`: Might indicate if the physics body is controlled externally.
*   `hax_fix_going_through_ground`: A "hack" to prevent entities from passing through the ground.
*   `linear_damping`, `angular_damping`: Standard physics properties that reduce velocity over time.

## Reference

This file contains 6028 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/4031555c1d1c131c3070b7c1789a4e40.xml).

---