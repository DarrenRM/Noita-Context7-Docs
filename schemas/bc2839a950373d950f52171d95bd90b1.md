---
title: bc2839a950373d950f52171d95bd90b1
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/bc2839a950373d950f52171d95bd90b1.xml
---

# bc2839a950373d950f52171d95bd90b1

This XML file, identified by the hash `bc2839a950373d950f52171d95bd90b1`, defines the structure and properties of various game components within Noita. It acts as a schema, outlining the data types and names for variables associated with different game entities and mechanics. This file is crucial for understanding how game objects are configured and how their behaviors are implemented. It dictates the parameters that can be set for AI, physics, visual effects, and many other aspects of the game.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct game component. Within each `<Component>`, there are `<Var>` elements that define individual variables.

*   **`<Schema>`:** The root element, containing a `hash` attribute that identifies the schema.
*   **`<Component>`:** Represents a specific game component. It has a `component_name` attribute that names the component (e.g., `AIAttackComponent`, `AIComponent`).
*   **`<Var>`:** Defines a variable within a component. It has the following attributes:
    *   `name`: The name of the variable (e.g., `use_probability`, `min_distance`).
    *   `size`: The size of the variable in bytes.
    *   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` which represents a string, `struct types::aabb` which represents a bounding box).

The `<Var>` elements can be empty, indicating that the variable's value is defined elsewhere or is implicitly handled by the game engine.

## Key Patterns

Several patterns are evident in the sampled data:

*   **Component-Based Design:** The game's functionality is broken down into modular components, each with its own set of configurable variables.
*   **Variable Naming Conventions:** Variable names are generally descriptive, indicating their purpose (e.g., `min_distance`, `angular_range_deg`, `teleportation_probability`).
*   **Data Type Variety:** A range of data types are used, including integers (`int`), floating-point numbers (`float`), booleans (`bool`), and strings. The use of C++ type names like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` suggests the underlying game engine's implementation.
*   **AI and Behavior Definition:** Many components, such as `AIAttackComponent` and `AIComponent`, define parameters related to enemy behavior, attack patterns, movement, and reactions.
*   **Material Interaction:** Components like `MaterialAreaCheckerComponent` and `MaterialInventoryComponent` suggest systems for managing and interacting with different in-game materials.
*   **Physics and Damage:** Variables related to knockback force, material damage, and physics object interaction are present, indicating how physical forces and material properties affect gameplay.
*   **Serialization and Internal Data:** The presence of variables like `mSerializedData`, `mCaster`, and `mCasterHerdId` points to internal game state management and object identification.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="angular_range_deg" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This section defines parameters for an AI's attack capabilities. `use_probability` likely controls how often an attack is attempted, `min_distance` and `max_distance` define the effective range, `angular_range_deg` specifies the cone of targeting, and `animation_name` links to the visual animation for the attack.

**2. `AIComponent` Related Material Damage Variables:**

```xml
    <Var name="materials_damage" size="1" type="bool" >
    </Var>

    <Var name="material_damage_min_cell_count" size="4" type="int" >
    </Var>

    <Var name="materials_that_damage" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

These variables within an `AIComponent` (or a related component) suggest that AI entities can interact with and damage materials. `materials_damage` enables this functionality, `material_damage_min_cell_count` might set a threshold for damage application, and `materials_that_damage` likely lists the specific materials that can be affected.

**3. `MaterialAreaCheckerComponent` Variables:**

```xml
    <Var name="update_every_x_frame" size="4" type="int" >
    </Var>

    <Var name="look_for_failure" size="1" type="bool" >
    </Var>

    <Var name="area_aabb" size="16" type="struct types::aabb" >
    </Var>

    <Var name="material" size="4" type="int" >
    </Var>
```

This component appears to be responsible for checking specific areas for certain materials. `update_every_x_frame` controls the frequency of checks, `look_for_failure` might indicate if the component is looking for a lack of a material, `area_aabb` defines the spatial bounds of the check, and `material` specifies the target material ID.

## Reference

This file contains 6592 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/bc2839a950373d950f52171d95bd90b1.xml).
---