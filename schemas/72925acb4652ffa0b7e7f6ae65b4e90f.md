---
title: 72925acb4652ffa0b7e7f6ae65b4e90f
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/72925acb4652ffa0b7e7f6ae65b4e90f.xml
---

# 72925acb4652ffa0b7e7f6ae65b4e90f

This XML file defines the structure and properties of various game components within Noita. It acts as a schema, outlining the data types and names for parameters that can be associated with different game entities or systems. These components likely govern the behavior, appearance, and interactions of objects, enemies, spells, and other elements in the game. Understanding this schema is crucial for analyzing game data and for modding, as it dictates how game logic and properties are represented.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute to identify it.

Within each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual variables or properties associated with that component. Each `<Var>` has the following attributes:

*   **`name`**: The name of the variable (e.g., `use_probability`, `min_distance`).
*   **`size`**: The size of the variable in bytes. This can indicate the data type or storage allocation.
*   **`type`**: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<float>` (representing a 2D vector of floats).

The `<Var>` elements themselves are typically empty, as their definition is contained within their attributes.

**Example Structure:**

```xml
<Schema hash="72925acb4652ffa0b7e7f6ae65b4e90f" >

  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <!-- ... other variables ... -->
  </Component>

  <Component component_name="AIComponent" >
    <!-- ... variables for AIComponent ... -->
  </Component>

  <!-- ... other components ... -->

</Schema>
```

## Key Patterns

Several patterns emerge from the sampled data:

*   **Component-Based Design**: The game appears to use a component-based architecture, where functionality is added to entities by attaching different components.
*   **Variable Naming Conventions**: Variable names are descriptive and often indicate their purpose (e.g., `attack_ranged_offset_x`, `volume_autofade_speed`).
*   **Data Type Variety**: A range of data types are used, from simple booleans and integers to floating-point numbers and complex vector types, suggesting a sophisticated game engine.
*   **AI and Physics Focus**: Components like `AIAttackComponent`, `AIComponent`, `PhysicsThrowableComponent`, and `IKLimbsAnimatorComponent` suggest a strong emphasis on artificial intelligence and physics simulation.
*   **Spatial and Temporal Properties**: Many variables relate to spatial properties (distances, offsets, positions, vectors) and temporal properties (durations, frame counts, speeds).
*   **Boolean Flags**: `bool` type variables are frequently used as flags to enable or disable specific behaviors (e.g., `attack_ranged_enabled`, `auto_play_if_enabled`).
*   **String References**: String types are used for names, such as `animation_name` and `attack_ranged_entity_file`, likely referencing other game assets.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**: This component seems to define the parameters for an AI's attack capabilities.
    *   `use_probability` (int): Likely determines how often this attack is used.
    *   `min_distance` (float) and `max_distance` (float): Define the effective range of the attack.
    *   `animation_name` (string): Specifies the animation to play when attacking.
    *   `attack_ranged_entity_file` (string): Points to the entity file (e.g., projectile) to be spawned for ranged attacks.

2.  **`AIComponent`**: This is a more general AI component, likely managing overall AI behavior. The sampled variables suggest it can control playback of sounds or animations based on game state.
    *   `auto_play_if_enabled` (bool): Whether to automatically play something if the component is enabled.
    *   `play_on_component_enable` (bool): Whether to play when the component is first enabled.
    *   `volume_autofade_speed` (float): Controls how quickly volume fades.

3.  **`PhysicsThrowableComponent`**: This component defines properties related to objects that can be thrown.
    *   `throw_force_coeff` (float): A coefficient influencing the force applied when throwing.
    *   `max_throw_speed` (float): The maximum speed an object can achieve when thrown.
    *   `tip_check_offset_min` (float) and `tip_check_offset_max` (float): Likely related to collision detection or physics stability when an object is held or thrown.

## Reference

This file contains 6912 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/72925acb4652ffa0b7e7f6ae65b4e90f.xml).

---