---
title: 6bd651775a5c4c010b3bc01ece559ab3
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/6bd651775a5c4c010b3bc01ece559ab3.xml
---

# 6bd651775a5c4c010b3bc01ece559ab3

This XML file defines the structure and properties of various game components used in Noita. These components are the building blocks for entities, dictating their behavior, appearance, and interactions within the game world. This schema file acts as a blueprint, specifying the types and names of variables that each component can have, along with their data types and sizes. Understanding these schemas is crucial for analyzing game mechanics, debugging, and for modders looking to alter or create new game content.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct type of game component. The root element is `<Schema>`, which contains a `hash` attribute.

Each `<Component>` element has a `component_name` attribute that uniquely identifies the component. Inside each `<Component>`, there are `<Var>` elements, which define individual properties or variables associated with that component.

Each `<Var>` element has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<float>` (a 2D vector of floats).

The structure is hierarchical: `<Schema>` contains `<Component>`s, and `<Component>`s contain `<Var>`s.

## Key Patterns

*   **Component-Based Design:** The file clearly illustrates Noita's component-based entity system, where different functionalities are encapsulated in distinct components.
*   **Variable Definitions:** Each component's behavior is defined by a set of variables, each with a specific name, size, and type. This allows for fine-grained control over game entity properties.
*   **Data Type Variety:** The file showcases a range of data types, from simple primitives to complex custom classes for vectors and transformations, indicating the sophistication of the game's internal systems.
*   **Naming Conventions:** Component and variable names often reflect their purpose (e.g., `AIAttackComponent`, `speed`, `gravity`, `sprite_hotspot_name`).
*   **String Representation:** C++ string types are represented with their full class names, indicating the underlying implementation.
*   **Vector and Transform Types:** The presence of types like `ceng::math::CVector2<float>` and `struct ceng::math::CXForm<float>` suggests that geometric and positional data are handled by dedicated math libraries.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**
This component appears to define the parameters for an AI's attack capabilities.
```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
  </Component>
```
This sample shows variables related to attack probability, range, targeting angles, animation triggers, and the specific entity file to be spawned for ranged attacks.

**2. `CrawlerAnimalComponent`:**
This component seems to define the physics and movement properties for creatures that crawl, potentially on surfaces like ceilings.
```xml
  <Component component_name="CrawlerAnimalComponent" >
    <Var name="ray_length" size="4" type="float" >
    </Var>
    <Var name="gravity" size="4" type="float" >
    </Var>
    <Var name="speed" size="4" type="float" >
    </Var>
    <Var name="collision_damage" size="4" type="float" >
    </Var>
  </Component>
```
Variables here control ray casting for ground detection, gravity, movement speed, and damage dealt upon collision.

**3. `HotspotComponent`:**
This component likely defines a specific point of interest or attachment point on a sprite or entity.
```xml
  <Component component_name="HotspotComponent" >
    <Var name="offset" size="8" type="class ceng::math::CVector2<float>" >
    </Var>
    <Var name="sprite_hotspot_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
  </Component>
```
It includes an `offset` (a 2D vector) and a `sprite_hotspot_name`, suggesting it's used for aligning sprites or defining interaction points.

## Reference

This file contains 7052 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/6bd651775a5c4c010b3bc01ece559ab3.xml).

---