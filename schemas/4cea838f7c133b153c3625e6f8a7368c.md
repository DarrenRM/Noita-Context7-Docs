---
title: 4cea838f7c133b153c3625e6f8a7368c
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/4cea838f7c133b153c3625e6f8a7368c.xml
---

# 4cea838f7c133b153c3625e6f8a7368c

This XML file, identified by the hash `4cea838f7c133b153c3625e6f8a7368c`, defines the structure and data types for various game components within Noita. It acts as a schema, outlining how different game elements are configured and how their properties are represented in the game's data files. This is crucial for understanding how entities, behaviors, and physical properties are implemented and for potential modding. The file specifies the names, sizes, and types of variables associated with each component, enabling the game engine to correctly load and interpret these configurations.

## File Structure

The file is structured as a series of `<Component>` elements, each representing a distinct type of game component. The root element is `<Schema>` which contains these components.

Each `<Component>` element has a `component_name` attribute that uniquely identifies the type of component it defines. Inside each `<Component>`, there are `<Var>` elements.

Each `<Var>` element represents a variable or property of that component and has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or custom class types like `class ConfigExplosion`.

The structure is hierarchical: a `<Schema>` contains multiple `<Component>`s, and each `<Component>` contains multiple `<Var>`s.

## Key Patterns

*   **Component-Based Design:** The file clearly follows a component-based architecture, where game entities are composed of various components, each responsible for a specific aspect of their behavior or properties.
*   **Variable Definitions:** Each component's properties are defined using `<Var>` tags, specifying their name, size, and data type. This provides a clear schema for how data should be structured.
*   **Data Type Variety:** The file showcases a range of data types, from simple primitives (`int`, `float`, `bool`) to complex C++ standard library types (strings) and custom game classes (e.g., `ConfigExplosion`, `ceng::math::CVector2<float>`).
*   **AI and Physics Focus:** Several components observed in the samples relate to Artificial Intelligence (`AIAttackComponent`, `AIComponent`, `FishAIComponent`) and physics (`PhysicsComponent`). This suggests a significant portion of the file is dedicated to defining entity behaviors and interactions.
*   **Configuration Parameters:** Many variables appear to be configuration parameters that control specific aspects of a component's functionality, such as attack ranges, animation names, explosion triggers, and physics properties like damping.
*   **String Representation:** The use of `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` for string types indicates that string data is handled using C++'s standard string implementation.
*   **Vector Types:** The presence of `ceng::math::CVector2<float>` suggests that 2D vector data (likely for positions, velocities, or dimensions) is used extensively.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**
This component defines parameters related to an entity's attack capabilities.

```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    </Component>
```
*   **Explanation:** This component details how an AI entity attacks. `use_probability` likely controls the chance of attacking, `min_distance` and `max_distance` define the attack range, `angular_range_deg` specifies the cone of attack, `animation_name` links to an animation, and `attack_ranged_entity_file` points to the projectile or entity spawned during a ranged attack.

**2. `ExplosionComponent`:**
This component defines the properties of an explosion.

```xml
  <Component component_name="ExplosionComponent" >
    <Var name="trigger" size="4" type="enum EXPLOSION_TRIGGER_TYPE::Enum" >
    </Var>
    <Var name="config_explosion" size="356" type="class ConfigExplosion" >
    </Var>
    <Var name="timeout_frames" size="4" type="int" >
    </Var>
    <Var name="kill_entity" size="1" type="bool" >
    </Var>
  </Component>
```
*   **Explanation:** This component governs explosions. `trigger` specifies when the explosion occurs (e.g., on impact, on death), `config_explosion` likely references a more detailed explosion configuration, `timeout_frames` sets how long the explosion lasts, and `kill_entity` determines if the explosion destroys the entity that spawned it.

**3. `PhysicsComponent` (implied from sample lines):**
While a full `PhysicsComponent` is not fully shown, the presence of variables like `linear_damping` and `angular_damping` suggests its structure.

```xml
    <Var name="linear_damping" size="4" type="float" >
    </Var>
    <Var name="angular_damping" size="4" type="float" >
    </Var>
    <Var name="allow_sleep" size="1" type="bool" >
    </Var>
    <Var name="is_bullet" size="1" type="bool" >
    </Var>
    <Var name="buoyancy" size="4" type="float" >
    </Var>
```
*   **Explanation:** These variables define physical properties. `linear_damping` and `angular_damping` control how quickly an object loses linear and rotational velocity, `allow_sleep` determines if the physics engine can put the object to sleep when inactive, `is_bullet` might flag it for specific physics handling, and `buoyancy` affects its behavior in fluids.

## Reference

This file contains 6436 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/4cea838f7c133b153c3625e6f8a7368c.xml).

---