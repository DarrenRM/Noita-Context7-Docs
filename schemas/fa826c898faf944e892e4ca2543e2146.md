---
title: fa826c898faf944e892e4ca2543e2146
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/fa826c898faf944e892e4ca2543e2146.xml
---

---

# fa826c898faf944e892e4ca2543e2146

This XML file, identified by the hash `fa826c898faf944e892e4ca2543e2146`, defines the schema for various game components and their properties within Noita. It acts as a blueprint, specifying the structure and data types for different game elements that can be attached to entities. These components dictate behaviors, attributes, and functionalities, ranging from AI actions and audio properties to electrical interactions and visual effects. Understanding this schema is crucial for comprehending how game entities are constructed and how their properties are defined.

## File Structure

The file is structured as a root `<Schema>` element containing multiple `<Component>` elements. Each `<Component>` represents a distinct type of game component and has a `component_name` attribute. Inside each `<Component>`, there are `<Var>` elements, each defining a specific variable or property associated with that component.

Each `<Var>` element typically has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, `struct ValueRange`).

The `type` attribute often uses C++-like type names, indicating the underlying data representation. For string types, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` is commonly used. For more complex types like vectors or ranges, custom struct names like `ceng::math::CVector2<float>` or `struct ValueRange` are employed.

## Key Patterns

*   **Component-Based Architecture:** The file clearly follows a component-based design, where different functionalities are encapsulated within distinct components. This allows for modularity and reusability of game logic.
*   **Variable Definitions:** Each component's properties are defined as individual `<Var>` elements, specifying their name, size, and data type. This provides a structured way to manage and serialize game data.
*   **Data Type Variety:** The schema includes a range of data types, from primitive types like integers and floats to more complex C++ standard library types and custom structs, reflecting the diverse needs of game development.
*   **AI and Behavior Components:** Several components appear to be related to Artificial Intelligence and entity behavior, such as `AIAttackComponent` and `AIComponent`, suggesting how enemies and other entities might act.
*   **Audio and Visual Components:** Components like `AudioListenerComponent`, `AudioLoopComponent`, and those related to particle effects (implied by variables like `color`, `offset`, `x_vel_min`, etc.) indicate definitions for sound and visual elements.
*   **Physics and Interaction Components:** Components like `ElectricityReceiverComponent` and `ElectricitySourceComponent` point to systems for handling physical interactions and game mechanics like electricity.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`:**
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_count_min" size="4" type="int" >
      </Var>
    </Component>
    ```
    This component defines parameters for an AI's attack capabilities. It includes variables for attack probability, range (`min_distance`, `max_distance`), targeting angle (`angular_range_deg`), associated animations (`animation_name`), and properties for ranged attacks like the entity file to spawn (`attack_ranged_entity_file`) and the number of entities to spawn (`attack_ranged_entity_count_min`).

2.  **`AudioLoopComponent`:**
    ```xml
    <Component component_name="AudioLoopComponent" >
      <Var name="file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="event_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="auto_play" size="1" type="bool" >
      </Var>
    </Component>
    ```
    This component is responsible for defining looping audio effects. It specifies the audio file to play (`file`), an associated event name (`event_name`), and a boolean flag to control whether the audio should play automatically (`auto_play`).

3.  **Particle/Effect Related Variables (within an un-named component in the third sample):**
    ```xml
    <Var name="color" size="4" type="unsigned int" >
    </Var>
    <Var name="offset" size="8" type="class ceng::math::CVector2<float>" >
    </Var>
    <Var name="x_vel_min" size="4" type="float" >
    </Var>
    <Var name="y_vel_min" size="4" type="float" >
    </Var>
    <Var name="x_vel_max" size="4" type="float" >
    </Var>
    <Var name="y_vel_max" size="4" type="float" >
    </Var>
    ```
    These variables, likely part of a component related to particle systems or visual effects, define properties such as the color of the effect (as an unsigned integer, likely representing RGBA), an offset vector for positioning, and minimum/maximum velocity ranges for particles in the X and Y directions.

## Reference

This file contains 6748 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/fa826c898faf944e892e4ca2543e2146.xml).