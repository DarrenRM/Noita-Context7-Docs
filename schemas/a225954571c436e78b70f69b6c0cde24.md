---
title: a225954571c436e78b70f69b6c0cde24
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/a225954571c436e78b70f69b6c0cde24.xml
---

# a225954571c436e78b70f69b6c0cde24

This XML file defines the structure and properties of various game components used in Noita. These components are the building blocks for entities within the game, dictating their behavior, appearance, and interactions. By defining these components, the game engine knows how to instantiate and manage everything from enemies and items to environmental elements and player abilities. This file acts as a schema, outlining the data fields and their types for each component type.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute to identify it.

Inside each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual properties or variables associated with that component. Each `<Var>` has the following attributes:

*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can range from primitive types like `int`, `float`, and `bool` to more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or custom math types like `class ceng::math::CVector2<float>`.

The structure is hierarchical: `<Schema>` contains `<Component>`s, and `<Component>`s contain `<Var>`s.

## Key Patterns

*   **Component-Based Architecture:** The file clearly demonstrates a component-based design pattern, where game entities are composed of various functional components.
*   **Data Type Variety:** A wide range of data types are used, from simple integers and booleans to complex string representations and vector types, indicating a sophisticated data management system.
*   **Naming Conventions:** Variable names are descriptive, often indicating their purpose (e.g., `use_probability`, `damage_per_frame`, `item_name`).
*   **String Representation:** C++ standard library string types are frequently used, indicated by names like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`.
*   **Vector Types:** Custom vector types, such as `class ceng::math::CVector2<float>`, are used for representing 2D positions or directions.
*   **Enum Types:** Some variables use `enum` types, like `ARC_TYPE::Enum`, suggesting predefined sets of values for certain properties.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**: This component appears to define parameters related to an AI's attack capabilities.
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      </Component>
    ```
    This shows variables for attack probability, range, aiming angles, and the specific entity file to be spawned for ranged attacks.

2.  **`AreaDamageComponent`**: This component defines properties for an area that inflicts damage over time.
    ```xml
    <Component component_name="AreaDamageComponent" >
      <Var name="aabb_min" size="8" type="class ceng::math::CVector2<float>" >
      </Var>
      <Var name="aabb_max" size="8" type="class ceng::math::CVector2<float>" >
      </Var>
      <Var name="damage_per_frame" size="4" type="float" >
      </Var>
      <Var name="death_cause" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
    </Component>
    ```
    It includes bounding box limits (`aabb_min`, `aabb_max`), the damage dealt per frame, and the cause of death for entities affected by this area.

3.  **`ItemComponent`**: This component describes the properties of an in-game item.
    ```xml
    <Component component_name="ItemComponent" >
      <Var name="item_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="is_stackable" size="1" type="bool" >
      </Var>
      <Var name="is_consumable" size="1" type="bool" >
      </Var>
      <Var name="uses_remaining" size="4" type="int" >
      </Var>
    </Component>
    ```
    This shows that items have names, can be stackable or consumable, and may have a limited number of uses.

## Reference

This file contains 6128 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/a225954571c436e78b70f69b6c0cde24.xml).

---