---
title: 1f1959fa8a6df924e67e8cc6eb3d78d7
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/1f1959fa8a6df924e67e8cc6eb3d78d7.xml
---

# 1f1959fa8a6df924e67e8cc6eb3d78d7

This XML file, identified by the hash `1f1959fa8a6df924e67e8cc6eb3d78d7`, defines the structure and properties of various game components within Noita. It acts as a schema or blueprint, detailing the types and sizes of data associated with different game mechanics, entities, and behaviors. This file is crucial for the game's engine to understand how to load, interpret, and utilize these components, influencing everything from enemy AI and physics to visual effects and player interactions.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct game component. The root element `<Schema>` encloses all these components and includes a `hash` attribute.

Each `<Component>` element has a `component_name` attribute that clearly identifies the type of component it defines (e.g., `AIAttackComponent`, `CellEaterComponent`, `EnergyShieldComponent`).

Inside each `<Component>`, there are multiple `<Var>` elements. These `<Var>` elements define individual variables or properties associated with that component. Each `<Var>` has the following attributes:
*   `name`: The name of the variable (e.g., `use_probability`, `radius`, `max_energy`).
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` which represents a string).

The `<Var>` elements themselves are empty, indicating that their definition is solely based on their attributes and the schema's interpretation of them.

## Key Patterns

*   **Component-Based Architecture:** The file clearly follows a component-based design, where functionality is broken down into modular components.
*   **Variable Definitions:** Each component is described by a set of named variables with specified data types and sizes. This allows for precise data serialization and deserialization.
*   **Data Types:** Common C++ data types are used, such as `int` for integers, `float` for floating-point numbers, and `bool` for boolean values. String types are represented by a more verbose C++ class name.
*   **Size Specification:** The `size` attribute is important for understanding how data is laid out in memory or in serialized files.
*   **Organization:** Components appear to be grouped logically, though the exact order might not be strictly significant beyond defining the schema itself.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**
This component defines parameters related to an AI's attack capabilities.
```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="state_duration_frames" size="4" type="int" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
  </Component>
```
This shows variables like `use_probability` (an integer), `min_distance` and `max_distance` (floats defining attack range), `angular_range_deg` (float for attack cone), `state_duration_frames` (integer for how long an attack state lasts), and `animation_name` and `attack_ranged_entity_file` (strings specifying visual animations and projectile entities).

**2. `CellEaterComponent`:**
This component likely defines the behavior of entities that consume or "eat" surrounding materials.
```xml
  <Component component_name="CellEaterComponent" >
    <Var name="radius" size="4" type="float" >
    </Var>
    <Var name="eat_probability" size="4" type="int" >
    </Var>
    <Var name="ignored_material" size="4" type="int" >
    </Var>
    <Var name="materials" size="12" type="class std::vector<int,class std::allocator<int> >" >
    </Var>
  </Component>
```
Here, `radius` defines the area of effect, `eat_probability` controls the chance of eating, `ignored_material` specifies a material that won't be eaten, and `materials` is a vector of integers, likely representing a list of materials that *can* be eaten.

**3. `EnergyShieldComponent`:**
This component describes the properties of an energy shield.
```xml
  <Component component_name="EnergyShieldComponent" >
    <Var name="radius" size="4" type="float" >
    </Var>
    <Var name="damage_multiplier" size="4" type="float" >
    </Var>
    <Var name="max_energy" size="4" type="float" >
    </Var>
    <Var name="energy" size="4" type="float" >
    </Var>
  </Component>
```
This includes `radius` for the shield's size, `damage_multiplier` for how much damage it mitigates, `max_energy` for its capacity, and `energy` for its current charge.

## Reference

This file contains 6568 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/1f1959fa8a6df924e67e8cc6eb3d78d7.xml).

---