---
title: ce242373f6bfd4151ed52fbc53f2a792
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/ce242373f6bfd4151ed52fbc53f2a792.xml
---

# ce242373f6bfd4151ed52fbc53f2a792

This XML file, identified by the hash `ce242373f6bfd4151ed52fbc53f2a792`, defines the schema for various game components and their properties within Noita. It acts as a blueprint for how different game entities (like enemies, items, or environmental elements) are structured and configured. By defining these components and their associated variables, this file dictates the behavior, appearance, and interactions of many elements in the game world. Understanding this schema is crucial for anyone looking to delve into the game's data, particularly for modding purposes, as it outlines the fundamental building blocks of game objects.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct type of game component. The root element `<Schema>` encloses all these components and includes a `hash` attribute, likely for identification and integrity checking.

Each `<Component>` element has a `component_name` attribute that clearly identifies the type of component it defines (e.g., `AIAttackComponent`, `AIComponent`, `ArcComponent`, `AreaDamageComponent`).

Inside each `<Component>`, there are multiple `<Var>` elements. These `<Var>` elements define the individual properties or variables associated with that component. Each `<Var>` has the following attributes:

*   **`name`**: The name of the variable (e.g., `use_probability`, `min_distance`, `lifetime`, `is_kinematic`).
*   **`size`**: The size of the variable in bytes. This can vary depending on the data type.
*   **`type`**: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, as well as more complex types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `struct LensValue<float>`, and `class ceng::math::CVector2<float>`. It also includes `enum` types, indicating a set of named constants.

The `<Var>` elements themselves are typically empty, meaning their values are defined elsewhere, likely in other data files that reference these schemas.

## Key Patterns

*   **Component-Based Design**: The file clearly follows a component-based architecture, where game entities are composed of various functional components.
*   **Variable Definitions**: Each component is defined by a set of variables, each with a specific name, size, and data type.
*   **Data Types**: A variety of data types are used, ranging from simple primitives to complex C++ class representations and enums. This indicates a sophisticated underlying game engine.
*   **String Representation**: Strings are consistently represented using `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, suggesting a C++ implementation.
*   **Vector Types**: `ceng::math::CVector2<float>` and `ceng::math::CVector2<int>` are used for 2D vector data, common in game development for positions, velocities, or dimensions.
*   **Enums**: The presence of `enum` types like `ARC_TYPE::Enum` and `INVENTORY_KIND::Enum` signifies that certain variables are restricted to a predefined set of values, improving data integrity and readability.
*   **Boolean Flags**: Many `bool` variables are present, acting as flags to enable or disable specific behaviors or properties (e.g., `can_fly`, `is_equipable_forced`, `is_kinematic`).

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This snippet shows variables related to an AI's attack behavior. It defines parameters like the probability of using an attack, the range, and the specific animation and entity file to be used for ranged attacks.

**2. `AIComponent` and `ArcComponent` Variables:**

```xml
  <Component component_name="AIComponent" >
    </Var>

    <Var name="can_fly" size="1" type="bool" >
    </Var>

    <Var name="can_walk" size="1" type="bool" >
    </Var>
  </Component>

  <Component component_name="ArcComponent" >

    <Var name="type" size="4" type="enum ARC_TYPE::Enum" >
    </Var>

    <Var name="material" size="4" type="int" >
    </Var>

    <Var name="lifetime" size="4" type="int" >
    </Var>

  </Component>
```

This shows parts of the `AIComponent`, defining basic movement capabilities like `can_fly` and `can_walk`. It also introduces the `ArcComponent`, which seems to define properties for arc-like effects or projectiles, including its `type` (from an enum), `material`, and `lifetime`.

**3. `ItemComponent` and `PhysicsComponent` Variables:**

```xml
  <Component component_name="ItemComponent" >
    </Var>

    <Var name="is_equipable_forced" size="1" type="bool" >
    </Var>

    <Var name="ui_sprite" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="preferred_inventory" size="4" type="enum INVENTORY_KIND::Enum" >
    </Var>

    <Var name="is_pickable" size="1" type="bool" >
    </Var>

  </Component>

  <Component component_name="PhysicsComponent" >
    <Var name="is_kinematic" size="1" type="bool" >
    </Var>

    <Var name="is_character" size="1" type="bool" >
    </Var>

    <Var name="initial_velocity" size="8" type="class ceng::math::CVector2<float>" >
    </Var>
```

This sample highlights variables for an `ItemComponent`, such as whether it's forced to be equipable, its UI sprite, preferred inventory slot, and pickability. It also shows variables from a `PhysicsComponent`, including whether an object is kinematic or a character, and its initial velocity.

## Reference

This file contains 5984 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/ce242373f6bfd4151ed52fbc53f2a792.xml).

---