---
title: 0f15e325744e0119b07a54872ababaff
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/0f15e325744e0119b07a54872ababaff.xml
---

# 0f15e325744e0119b07a54872ababaff

This XML file defines the structure and properties of various game components within Noita. It acts as a schema, outlining the data types and names for variables associated with different game entities and systems. These definitions are crucial for the game engine to correctly interpret and utilize the data for entities, their behaviors, and their physical properties. Essentially, it's a blueprint for how game data is organized and what kind of information each part of the game can hold.

## File Structure

The file is structured as a root `<Schema>` element containing multiple `<Component>` elements. Each `<Component>` represents a distinct set of properties or functionalities that can be attached to game entities.

Within each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual variables, specifying their:
*   `name`: The identifier for the variable.
*   `size`: The memory size allocated for the variable (often in bytes).
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` for strings, `enum GAME_EFFECT::Enum`, `class ceng::math::CVector2<float>` for 2D vectors).

The structure is hierarchical, with the schema containing components, and components containing variables.

**Example Structure:**

```xml
<Schema hash="...">
  <Component component_name="...">
    <Var name="..." size="..." type="...">
    </Var>
    <Var name="..." size="..." type="...">
    </Var>
    ...
  </Component>
  <Component component_name="...">
    ...
  </Component>
  ...
</Schema>
```

## Key Patterns

Several patterns are evident in the sampled data:

*   **Component-Based Design:** The game appears to use a component-based architecture, where entities are composed of various components that define their capabilities (e.g., AI, health, physics, attacks).
*   **Variable Naming Conventions:** Variable names are descriptive and often follow a camelCase or snake_case convention. They clearly indicate the purpose of the variable (e.g., `use_probability`, `min_distance`, `blood_multiplier`, `mana_current`).
*   **Data Type Variety:** A range of data types are used, from fundamental types like integers, floats, and booleans, to more complex types like strings and custom vector classes, and enumerations for specific game states or effects.
*   **String Representation:** String types are consistently represented as `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, indicating a standard C++ string implementation.
*   **Enum Usage:** Enumerations are used for predefined sets of values, such as `GAME_EFFECT::Enum` and `HIT_EFFECT::Enum`, providing type safety and readability.
*   **Vector Representation:** 2D vectors are represented by `class ceng::math::CVector2<float>`, suggesting a custom math library is in use.
*   **Boolean Flags:** Many variables are booleans (`size="1" type="bool"`) used as flags to enable or disable specific behaviors or features (e.g., `create_ragdoll`, `kills_entity`, `mActiveState`).

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent` Variables:**
    ```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    ```
    This section defines parameters for an AI's attack capabilities. It includes variables for the probability of using an attack, the effective range (`min_distance`, `max_distance`), the animation to play during the attack, and the entity file to spawn for ranged attacks.

2.  **`HealthBarComponent` and `HitEffectComponent` Variables:**
    ```xml
    <Component component_name="HealthBarComponent" >
    </Component>
    <Component component_name="HitEffectComponent" >
      <Var name="condition_effect" size="4" type="enum GAME_EFFECT::Enum" >
      </Var>
      <Var name="effect_hit" size="4" type="enum HIT_EFFECT::Enum" >
      </Var>
    </Component>
    ```
    These components relate to visual feedback for health and damage. `HealthBarComponent` likely manages the display of a health bar, while `HitEffectComponent` defines the visual effects that occur when an entity is hit, using enumerations to specify the type of effect.

3.  **`PhysicsImageShapeComponent` Variables:**
    ```xml
    <Component component_name="PhysicsImageShapeComponent" >
      <Var name="is_root" size="1" type="bool" >
      </Var>
      <Var name="body_id" size="4" type="int" >
      </Var>
      <Var name="use_sprite" size="1" type="bool" >
      </Var>
      <Var name="offset_x" size="4" type="float" >
      </Var>
    </Component>
    ```
    This component deals with the physical representation of an entity. It includes flags like `is_root` and `use_sprite`, an identifier for the physics body (`body_id`), and positional offsets.

## Reference

This file contains 7068 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/0f15e325744e0119b07a54872ababaff.xml).

---