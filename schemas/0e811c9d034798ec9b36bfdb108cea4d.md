---
title: 0e811c9d034798ec9b36bfdb108cea4d
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/0e811c9d034798ec9b36bfdb108cea4d.xml
---

# 0e811c9d034798ec9b36bfdb108cea4d

This XML file defines the structure and types of data used by the game Noita, specifically for its internal data schema. It acts as a blueprint, outlining the various components and their associated variables that make up game entities, behaviors, and properties. This schema file is crucial for understanding how game data is organized and for potentially modifying or extending it.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` represents a distinct functional part or aspect of a game entity.

Within each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual data fields (variables) associated with that component. Each `<Var>` has attributes that describe its properties:

*   **`name`**: The identifier for the variable.
*   **`size`**: The memory size allocated for the variable (often in bytes).
*   **`type`**: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` which represents a string, or `enum GAME_EFFECT::Enum`).

The structure can be visualized as:

```xml
<Schema hash="...">
  <Component component_name="...">
    <Var name="..." size="..." type="...">
    </Var>
    <Var name="..." size="..." type="...">
    </Var>
    ...
  </Component>
  <Component component_name="...">
    ...
  </Component>
  ...
</Schema>
```

## Key Patterns

Several patterns are evident in the sampled data:

*   **Component-Based Design**: The game's data is organized around components, suggesting a component-entity system. Each component encapsulates a specific set of functionalities or properties.
*   **Variable Definitions**: Each component is composed of numerous variables, detailing its behavior and attributes.
*   **Data Types**: A variety of data types are used, including primitive types (`int`, `float`, `bool`), string types (represented by `class std::basic_string...`), and enumerations (`enum`).
*   **Naming Conventions**: Variable names are descriptive, often indicating their purpose (e.g., `use_probability`, `min_distance`, `animation_name`, `mana_current`).
*   **Component Categories**: Components appear to be categorized by their function, such as AI-related components (`AIAttackComponent`, `AIComponent`, `AnimalAIComponent`), game mechanics (`AltarComponent`, `GunComponent`), and visual/rendering aspects (`HitEffectComponent`).

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**:
    This component defines parameters related to an AI's attack capabilities.
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      ...
    </Component>
    ```
    This shows how an AI's attack behavior is defined by variables controlling probability, range, targeting angles, and the specific projectile or effect used.

2.  **`AltarComponent`**:
    This component likely defines the behavior and properties of altars found in the game.
    ```xml
    <Component component_name="AltarComponent" >
      <Var name="recognized_entity_tags" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="good_fx_material" size="4" type="int" >
      </Var>
      <Var name="uses_remaining" size="4" type="int" >
      </Var>
      ...
    </Component>
    ```
    This indicates that altars can recognize specific entity types and have associated visual effects and a limited number of uses.

3.  **`HitEffectComponent`**:
    This component describes the visual and functional effects that occur when an entity is hit.
    ```xml
    <Component component_name="HitEffectComponent" >
      <Var name="condition_effect" size="4" type="enum GAME_EFFECT::Enum" >
      </Var>
      <Var name="effect_hit" size="4" type="enum HIT_EFFECT::Enum" >
      </Var>
      <Var name="value" size="4" type="int" >
      </Var>
      <Var name="image_animation_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      ...
    </Component>
    ```
    This shows that hit effects can be tied to specific game effects, hit effect types, numerical values, and even animated visual assets.

## Reference

This file contains 6676 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/0e811c9d034798ec9b36bfdb108cea4d.xml).

---