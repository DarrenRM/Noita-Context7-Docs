---
title: b3496a8b77d6a18bcd555d3184c6be00
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/b3496a8b77d6a18bcd555d3184c6be00.xml
---

# b3496a8b77d6a18bcd555d3184c6be00

This XML file, identified by the hash `b3496a8b77d6a18bcd555d3184c6be00`, defines the schema for various game components and their properties within Noita. It acts as a blueprint for how different game entities are structured and what data they hold. This is crucial for the game's engine to understand and instantiate objects, behaviors, and attributes. Essentially, it's a data dictionary that dictates the underlying mechanics and characteristics of game elements.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute to identify it.

Within each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual properties or variables associated with that component. Each `<Var>` has the following key attributes:

*   **`name`**: The identifier for the variable (e.g., `use_probability`, `min_distance`).
*   **`size`**: The size of the variable in bytes. This often correlates with the `type`.
*   **`type`**: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<int>` (a 2D vector of integers).

The structure is hierarchical: `<Schema>` contains `<Component>`s, and `<Component>`s contain `<Var>`s.

## Key Patterns

*   **Component-Based Architecture**: The file clearly follows a component-based design, where different functionalities (like AI attacks, inventories, or particle emissions) are encapsulated in distinct components.
*   **Variable Definitions**: Each component's behavior and data are defined by a list of variables, specifying their names, sizes, and types.
*   **Data Type Variety**: The file uses a range of data types, from simple booleans and integers to complex string types and custom vector classes, indicating the diverse nature of game data.
*   **AI and Behavior Focus**: Several components, such as `AIAttackComponent` and `AIComponent`, suggest a strong focus on defining enemy AI and their combat behaviors.
*   **Visual and Gameplay Elements**: Components like `InventoryComponent`, `InventoryGuiComponent`, and those related to particle emitters (`ParticleEmitterComponent`) indicate definitions for UI, inventory management, and visual effects.
*   **String Representation**: The common use of `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` for string types suggests that many properties, such as animation names or entity files, are referenced by their string identifiers.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
<Component component_name="AIAttackComponent" >
  <Var name="use_probability" size="4" type="int" >
  </Var>
  <Var name="min_distance" size="4" type="float" >
  </Var>
  <Var name="max_distance" size="4" type="float" >
  </Var>
  <Var name="angular_range_deg" size="4" type="float" >
  </Var>
  <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
  <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
</Component>
```

This snippet defines variables for an AI attack component. It includes parameters for attack probability, range (`min_distance`, `max_distance`), aiming (`angular_range_deg`), associated animations (`animation_name`), and the specific entity file to be spawned for ranged attacks (`attack_ranged_entity_file`).

**2. `InventoryComponent` Variables:**

```xml
<Component component_name="InventoryComponent" >
  <Var name="ui_container_type" size="4" type="int" >
  </Var>
  <Var name="ui_container_size" size="8" type="class ceng::math::CVector2<int>" >
  </Var>
  <Var name="ui_position_on_screen" size="8" type="class ceng::math::CVector2<int>" >
  </Var>
  <Var name="ui_element_sprite" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
</Component>
```

This section details variables for the inventory system. It specifies how the inventory UI should be displayed, including its container type, size (`ui_container_size`), position on screen (`ui_position_on_screen`), and the sprite used for its elements (`ui_element_sprite`).

**3. `ParticleEmitterComponent` Variables:**

```xml
<Component component_name="ParticleEmitterComponent" >
  <Var name="emission_interval_max_frames" size="4" type="int" >
  </Var>
  <Var name="emission_chance" size="4" type="int" >
  </Var>
  <Var name="custom_style" size="4" type="enum PARTICLE_EMITTER_CUSTOM_STYLE::Enum" >
  </Var>
  <Var name="is_emitting" size="1" type="bool" >
  </Var>
  <Var name="trail_gap" size="4" type="float" >
  </Var>
</Component>
```

This component defines parameters for particle emitters, which are used for visual effects. It includes settings for how often particles are emitted (`emission_interval_max_frames`), the probability of emission (`emission_chance`), custom visual styles (`custom_style`), whether emission is active (`is_emitting`), and the spacing for trail effects (`trail_gap`).

## Reference

This file contains 6460 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/b3496a8b77d6a18bcd555d3184c6be00.xml).

---