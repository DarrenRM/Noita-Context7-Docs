---
title: 32fd34b4e5038004f461db117e0fc69b
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/32fd34b4e5038004f461db117e0fc69b.xml
---

# 32fd34b4e5038004f461db117e0fc69b

This XML file defines the structure and properties of various game components used in Noita. It acts as a schema, outlining the data types, sizes, and names of variables associated with different game entities and systems. These definitions are crucial for the game engine to correctly load, interpret, and manage the behavior and attributes of in-game elements, from enemy AI to UI components and scripting functionalities.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct game component. The root element `<Schema>` contains these components and is identified by a `hash` attribute.

Each `<Component>` element has a `component_name` attribute that clearly identifies its purpose. Inside each component, `<Var>` elements define individual properties or variables. These `<Var>` elements have the following key attributes:

*   **`name`**: The identifier for the variable.
*   **`size`**: The size of the variable in bytes.
*   **`type`**: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` for strings, `enum ...` for enumerations, `class ceng::math::CVector2<float>` for 2D vectors).

The structure is hierarchical, with `<Schema>` at the top, containing multiple `<Component>` elements, which in turn contain multiple `<Var>` elements.

## Key Patterns

Several patterns are evident in the sampled data:

*   **Component-Based Design**: The game utilizes a component-based architecture, where functionality is broken down into modular components (e.g., `AIAttackComponent`, `AIComponent`, `BuildingUIComponent`).
*   **Variable Definitions**: Each component is defined by a set of variables, each with a specific name, size, and type. This allows for fine-grained control over game mechanics.
*   **String Representation**: String data types are consistently represented as `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, indicating a C++ standard library string.
*   **Numerical Types**: Standard numerical types like `int` and `float` are used for various parameters.
*   **Boolean Flags**: `bool` types are used for enabling or disabling features.
*   **Enumerations**: `enum` types are used for variables that can take on a predefined set of values, often representing states or categories (e.g., `BUILDINGUI_TYPE::Enum`, `LUA_VM_TYPE::Enum`).
*   **Vector Types**: Custom vector types, such as `class ceng::math::CVector2<float>`, are used for representing 2D positions or directions.
*   **AI and Behavior**: Components like `AIAttackComponent` and `AIComponent` suggest a focus on defining enemy behavior, attack patterns, and movement.
*   **UI Elements**: `BuildingUIComponent` indicates definitions related to user interface elements for buildings.
*   **Scripting Integration**: Components like the one containing `vm_type`, `execute_on_added`, and various `script_...` variables point to a robust scripting system that can be integrated with game entities.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This section defines parameters for an AI attack component. It includes variables for attack probability, range (`min_distance`, `max_distance`), the name of the attack animation, and the entity file to be used for ranged attacks.

**2. `BuildingUIComponent` Variables:**

```xml
  <Component component_name="BuildingUIComponent" >

    <Var name="building_type" size="4" type="enum BUILDINGUI_TYPE::Enum" >

    </Var>

    <Var name="pixel_stamp_material" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >

    </Var>

    <Var name="can_be_rotated" size="1" type="bool" >

    </Var>

  </Component>
```

This component defines properties for UI elements related to buildings. It specifies the type of building, the material used for its "pixel stamp," and whether the building can be rotated in the UI.

**3. Scripting Component Variables:**

```xml
    <Var name="vm_type" size="4" type="enum LUA_VM_TYPE::Enum" >

    </Var>

    <Var name="execute_on_added" size="1" type="bool" >

    </Var>

    <Var name="script_damage_received" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >

    </Var>

    <Var name="script_shot" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >

    </Var>
```

This set of variables indicates a component responsible for executing Lua scripts. It defines the type of Lua virtual machine (`vm_type`), conditions for script execution (e.g., `execute_on_added`), and names of script functions to be called upon specific game events like receiving damage or firing a shot.

## Reference

This file contains 6272 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/32fd34b4e5038004f461db117e0fc69b.xml).
---