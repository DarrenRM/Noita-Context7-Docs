---
title: c86d85cde6b887222170147fc35ec112
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/c86d85cde6b887222170147fc35ec112.xml
---

# c86d85cde6b887222170147fc35ec112

This XML file defines the schema for various game components in Noita. It acts as a blueprint, specifying the structure and data types for different game elements, such as AI behaviors, physical properties, visual representations, and more. These schemas are crucial for the game engine to correctly interpret and instantiate game objects and their associated logic. By defining these components, the game can manage complex entities with diverse functionalities.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct game component. The root element is `<Schema>`, which contains these components.

Each `<Component>` element has a `component_name` attribute that uniquely identifies the type of component it defines. Inside each `<Component>`, there are multiple `<Var>` elements.

Each `<Var>` element defines a variable or property associated with that component. These `<Var>` elements have the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) and `class std::vector<int,class std::allocator<int> >` (which represents a vector of integers).

The structure is hierarchical: `<Schema>` contains `<Component>`s, and `<Component>`s contain `<Var>`s.

## Key Patterns

*   **Component-Based Design:** The file clearly follows a component-based architecture, where game entities are composed of various independent components, each responsible for a specific aspect of their behavior or appearance.
*   **Variable Definitions:** Each component's properties are defined using `<Var>` tags, specifying their name, size, and data type. This allows for precise control over the data associated with each component.
*   **Data Type Variety:** The file showcases a range of data types, from simple integers and floats to strings and vectors, indicating the complexity of data that can be managed by these components.
*   **AI and Behavior Components:** Several components appear to define AI behaviors, such as `AIAttackComponent` and `AIComponent`, suggesting how enemies and other entities might act.
*   **Physical and Material Properties:** Components like `CellEaterComponent` and `LooseGroundComponent` define how game elements interact with the environment, including material properties and physical behaviors.
*   **Visual Representation:** Components like `PixelSpriteComponent` suggest how visual elements are defined, including image files and anchoring.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**
This component defines parameters related to an entity's attack capabilities. It includes variables for attack range, timing, animation, and projectile properties.

```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
  </Component>
```
This sample shows how an attack component might define probabilities, distances, angles, animation names, and the entity file for ranged attacks.

**2. `CellEaterComponent`:**
This component seems to define entities that consume or interact with specific materials in the game world.

```xml
  <Component component_name="CellEaterComponent" >
    <Var name="radius" size="4" type="float" >
    </Var>
    <Var name="eat_probability" size="4" type="int" >
    </Var>
    <Var name="ignored_material" size="4" type="int" >
    </Var>
    <Var name="materials" size="12" type="class std::vector<int,class std::allocator<int> >" >
    </Var>
  </Component>
```
This illustrates how a "cell eater" might have a radius of effect, an eating probability, a material it ignores, and a list of specific materials it targets.

**3. `LooseGroundComponent`:**
This component appears to define properties for ground or terrain elements that can break apart or be affected by physics.

```xml
  <Component component_name="LooseGroundComponent" >
    <Var name="probability" size="4" type="float" >
    </Var>
    <Var name="max_durability" size="4" type="int" >
    </Var>
    <Var name="chunk_material" size="4" type="int" >
    </Var>
  </Component>
```
This shows variables for the probability of breaking, maximum durability, and the material of the resulting chunks.

## Reference

This file contains 6484 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/c86d85cde6b887222170147fc35ec112.xml).

---