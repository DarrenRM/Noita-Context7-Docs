---
title: e4501141964d1d8c59e8bf332c8904c1
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/e4501141964d1d8c59e8bf332c8904c1.xml
---

# e4501141964d1d8c59e8bf332c8904c1

This file, `e4501141964d1d8c59e8bf332c8904c1.xml`, is a schema definition file for the game Noita. It defines the structure and types of data used for various game components. These schemas are crucial for the game's engine to understand and interpret the properties of entities, behaviors, and game mechanics. By defining these components and their associated variables, the game can accurately represent and simulate everything from enemy AI and damage models to physics and visual effects. This file acts as a blueprint for how game data is organized and read.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains a `hash` attribute. Inside the `<Schema>` element, the primary organizational unit is the `<Component>` tag. Each `<Component>` tag represents a distinct type of game component and has a `component_name` attribute that identifies it.

Within each `<Component>`, the individual data fields are defined by `<Var>` tags. Each `<Var>` tag has the following key attributes:

*   **`name`**: The name of the variable or property.
*   **`size`**: The size of the variable in bytes. This indicates the memory footprint of the data.
*   **`type`**: The data type of the variable. This can range from primitive types like `int`, `float`, and `bool` to more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or custom class types like `class ConfigDamagesByType`.

The `<Var>` tags themselves are typically empty, as their purpose is to define the structure and metadata of the variables, not to hold their values.

**Example Structure:**

```xml
<Schema hash="e4501141964d1d8c59e8bf332c8904c1" >
  <Component component_name="ComponentName" >
    <Var name="variable_name_1" size="4" type="int" >
    </Var>
    <Var name="variable_name_2" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    </Component>
  </Component>
</Schema>
```

## Key Patterns

Several patterns are evident in the sampled content:

*   **Component-Based Design**: The game utilizes a component-based architecture, where entities are composed of various components, each responsible for a specific aspect of their behavior or properties. This is clearly reflected in the `<Component>` tags.
*   **Variable Definitions**: Each component is broken down into individual variables defined by `<Var>` tags, specifying their name, size, and data type.
*   **Data Type Variety**: A mix of fundamental data types (`int`, `float`, `bool`) and more complex C++ class types are used, indicating a sophisticated underlying game engine.
*   **Naming Conventions**: Variable names are generally descriptive, hinting at their purpose (e.g., `use_probability`, `min_distance`, `max_hp`, `recharge_speed`).
*   **Size and Type Correlation**: The `size` attribute often correlates with the `type`. For instance, `int` and `float` are typically 4 bytes, while strings (`std::basic_string`) have larger sizes (e.g., 24 bytes, likely for internal string management).
*   **Enum Types**: Some variables, like `trigger` in `ExplosionComponent`, are defined with `enum` types, indicating a predefined set of possible values.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**: This component appears to define parameters related to an AI's attacking behavior.
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
    </Component>
    ```
    This sample shows variables controlling attack range, probability, and the specific entity file used for ranged attacks, along with animation names.

2.  **`DamageModelComponent`**: This component defines how entities take damage and their health properties.
    ```xml
    <Component component_name="DamageModelComponent" >
      <Var name="hp" size="4" type="float" >
      </Var>
      <Var name="max_hp" size="4" type="float" >
      </Var>
      <Var name="damage_multipliers" size="56" type="class ConfigDamagesByType" >
      </Var>
      <Var name="falling_damages" size="1" type="bool" >
      </Var>
    </Component>
    ```
    Here, we see variables for current health (`hp`), maximum health (`max_hp`), damage multipliers for different damage types, and a boolean to enable falling damage.

3.  **`ExplosionComponent`**: This component seems to be related to entities that can explode.
    ```xml
    <Component component_name="ExplosionComponent" >
      <Var name="trigger" size="4" type="enum EXPLOSION_TRIGGER_TYPE::Enum" >
      </Var>
    </Component>
    ```
    This snippet shows a single variable, `trigger`, which is an enumeration type, likely defining *when* an explosion occurs (e.g., on death, on impact).

## Reference

This file contains 6412 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/e4501141964d1d8c59e8bf332c8904c1.xml).

---