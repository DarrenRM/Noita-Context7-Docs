---
title: 9b36d3cde5889cc2356d1d519b3b4e06
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/9b36d3cde5889cc2356d1d519b3b4e06.xml
---

# 9b36d3cde5889cc2356d1d519b3b4e06

This XML file defines the structure and properties of various game components used within Noita. It acts as a schema, outlining the data types, sizes, and names of variables that make up these components. These components are fundamental building blocks for entities in the game, dictating their behavior, appearance, and interactions. By defining these components in a structured format, Noita can efficiently load and manage game data, allowing for complex entity designs and behaviors. This file is crucial for understanding how different game elements are constructed and how they function.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute to identify it.

Inside each `<Component>`, there are `<Var>` elements. Each `<Var>` element defines a specific variable or property associated with that component. These `<Var>` elements have the following attributes:

*   **`name`**: The name of the variable (e.g., `use_probability`, `radius`, `script_shot`).
*   **`size`**: The size of the variable in bytes. This indicates the memory allocation for the variable.
*   **`type`**: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<int>` (which represents a 2D vector of integers).

The structure is hierarchical: `<Schema>` contains `<Component>`s, and `<Component>`s contain `<Var>`s.

## Key Patterns

*   **Component-Based Design**: The file clearly follows a component-based architecture, where game entities are composed of various reusable components. Each component encapsulates a specific set of functionalities or data.
*   **Variable Definitions**: The `<Var>` tags consistently define the properties of each component. The `name`, `size`, and `type` attributes provide a detailed specification for each variable.
*   **String Representation**: C++ string types are represented using a verbose `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`. This is a common pattern for handling strings in C++ game engines.
*   **Vector Types**: 2D vectors are represented using a `ceng::math::CVector2<T>` class, where `T` is the data type of the vector components (e.g., `int`).
*   **Boolean Representation**: Boolean values are represented with a `size="1"` and `type="bool"`.
*   **Scripting Hooks**: Several components, particularly those related to AI and entity behavior, include variables that are strings. These likely represent names of Lua scripts or functions that are called when specific game events occur (e.g., `script_shot`, `script_damage_received`).

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This section defines parameters for an AI's attack capabilities. It includes variables for the probability of using an attack, the range of the attack (`min_distance`, `max_distance`), the name of the attack animation, and the entity file to be spawned for ranged attacks.

**2. `AIComponent` Variables (partial):**

```xml
    <Var name="fly_smooth_y" size="1" type="bool" >
    </Var>

    <Var name="accel_x" size="4" type="float" >
    </Var>

    <Var name="pixel_gravity" size="4" type="float" >
    </Var>

    <Var name="swim_drag" size="4" type="float" >
    </Var>
```

This snippet shows variables related to an AI's movement and physics. `fly_smooth_y` suggests smooth vertical flight, `accel_x` controls horizontal acceleration, `pixel_gravity` indicates gravity's effect on movement, and `swim_drag` relates to resistance in water.

**3. `InteractableComponent` Variables:**

```xml
  <Component component_name="InteractableComponent" >

    <Var name="radius" size="4" type="float" >

    </Var>

    <Var name="ui_text" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >

    </Var>

    <Var name="name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >

    </Var>

  </Component>
```

This component defines properties for objects that can be interacted with. `radius` likely specifies the interaction range, `ui_text` could be the text displayed when interacting, and `name` is the internal name of the interactable object.

**4. `ScriptComponent` Variables (partial):**

```xml
    <Var name="remove_after_executed" size="1" type="bool" >
    </Var>

    <Var name="script_shot" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="script_collision_trigger_hit" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This component is related to scripting. `remove_after_executed` suggests a script that cleans itself up. `script_shot` and `script_collision_trigger_hit` are string variables that likely hold the names of Lua functions to be executed when the entity fires a shot or when a collision trigger is hit, respectively.

## Reference

This file contains 6864 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/9b36d3cde5889cc2356d1d519b3b4e06.xml).

---