---
title: 339d3e37e9975d0bb4afc8be97c94858
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/339d3e37e9975d0bb4afc8be97c94858.xml
---

---

# 339d3e37e9975d0bb4afc8be97c94858

This XML file defines the structure and properties of various game components used within Noita. It acts as a schema, outlining the data fields and their types for different game systems. These components are fundamental building blocks for entities, behaviors, and interactions within the game world. By defining these components, the game engine knows how to load, interpret, and utilize the data associated with each game element.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct game component. The root element is `<Schema>`, which contains all the component definitions.

Each `<Component>` element has a `component_name` attribute that uniquely identifies the type of component (e.g., `AIAttackComponent`, `AIComponent`, `CollisionTriggerComponent`).

Inside each `<Component>`, there are `<Var>` elements. These `<Var>` elements define the individual data fields (variables) that make up the component. Each `<Var>` element has the following attributes:

*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<float>` (which represents a 2D vector of floats).

There are no nested `<Var>` elements; the structure is flat within each component.

## Key Patterns

*   **Component-Based Architecture:** The file clearly demonstrates a component-based design, where game entities are composed of various functional components.
*   **Data Type Specificity:** The `type` attribute in `<Var>` elements is highly specific, often reflecting C++ data types, indicating the underlying implementation language of the game.
*   **String Representation:** Strings are consistently represented using `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`.
*   **Vector Representation:** 2D vectors are represented using `class ceng::math::CVector2<float>`.
*   **Boolean Representation:** Booleans are represented by `bool` and typically have a `size` of `1`.
*   **Numerical Data:** Integers and floats are common, with `int` and `float` types respectively.
*   **AI and Behavior:** Several components, such as `AIAttackComponent` and `AIComponent`, suggest a focus on defining enemy AI and behaviors.
*   **Physics and Collision:** Components like `CollisionTriggerComponent` and `PhysicsImageShapeComponent` indicate definitions related to physics and collision detection.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**

```xml
<Component component_name="AIAttackComponent" >
  <Var name="use_probability" size="4" type="int" >
  </Var>
  <Var name="min_distance" size="4" type="float" >
  </Var>
  <Var name="max_distance" size="4" type="float" >
  </Var>
  <Var name="angular_range_deg" size="4" type="float" >
  </Var>
  <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
  <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
</Component>
```
This component defines parameters for an AI's attack capabilities. It includes variables for attack probability, range (`min_distance`, `max_distance`), aiming angles (`angular_range_deg`), associated animations (`animation_name`), and the entity file to be spawned for ranged attacks (`attack_ranged_entity_file`).

**2. `CollisionTriggerComponent`:**

```xml
<Component component_name="CollisionTriggerComponent" >
  <Var name="width" size="4" type="float" >
  </Var>
  <Var name="height" size="4" type="float" >
  </Var>
  <Var name="radius" size="4" type="float" >
  </Var>
  <Var name="required_tag" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
  <Var name="remove_component_when_triggered" size="1" type="bool" >
  </Var>
</Component>
```
This component defines a trigger area for collision detection. It specifies the dimensions of the trigger (`width`, `height`, `radius`), a tag that must be present on an entity for the trigger to activate (`required_tag`), and a flag to remove the component once triggered (`remove_component_when_triggered`).

**3. `HotspotComponent`:**

```xml
<Component component_name="HotspotComponent" >
  <Var name="offset" size="8" type="class ceng::math::CVector2<float>" >
  </Var>
  <Var name="transform_with_scale" size="1" type="bool" >
  </Var>
  <Var name="sprite_hotspot_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
  </Var>
</Component>
```
This component likely defines a specific point of interest or attachment point on a sprite or entity. It includes an `offset` (a 2D vector), a flag to indicate if the hotspot should transform with the entity's scale, and the name of the sprite hotspot (`sprite_hotspot_name`).

## Reference

This file contains 6212 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/339d3e37e9975d0bb4afc8be97c94858.xml).