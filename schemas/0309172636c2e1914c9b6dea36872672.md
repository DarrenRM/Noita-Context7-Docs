---
title: 0309172636c2e1914c9b6dea36872672
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/0309172636c2e1914c9b6dea36872672.xml
---

# 0309172636c2e1914c9b6dea36872672

This XML file defines the structure and properties of various game components used in Noita. It acts as a schema, outlining the data types and names for variables associated with different game mechanics and entities. These definitions are crucial for the game engine to correctly load, interpret, and utilize the data for entities, behaviors, and world generation. Essentially, it's a blueprint for how game data is organized.

## File Structure

The file is structured as a series of `<Component>` elements, each representing a distinct game component. Within each `<Component>`, there are `<Var>` elements that define individual variables.

*   **`<Schema>`:** The root element, containing a `hash` attribute.
*   **`<Component>`:** Represents a specific game component. It has a `component_name` attribute that identifies the component (e.g., `AIAttackComponent`, `CellEaterComponent`).
*   **`<Var>`:** Defines a variable within a component. It has the following attributes:
    *   `name`: The name of the variable (e.g., `use_probability`, `radius`).
    *   `size`: The size of the variable in bytes.
    *   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, `struct ValueRange`, `class ceng::math::CVector2<int>`).

The structure is hierarchical, with `<Var>` elements nested within `<Component>` elements.

## Key Patterns

*   **Component-Based Design:** The game's data is organized around distinct components, each responsible for a specific aspect of an entity or game mechanic.
*   **Variable Definitions:** Each component is described by a set of variables, detailing its configurable parameters.
*   **Data Types:** A variety of data types are used, including primitive types (`int`, `float`, `bool`), string types (`class std::basic_string...`), and custom struct/class types (e.g., `struct ValueRange`, `class ceng::math::CVector2<int>`).
*   **Naming Conventions:** Variable names are generally descriptive, indicating their purpose (e.g., `min_distance`, `eat_probability`, `lifetime`).
*   **Size and Type:** The `size` and `type` attributes provide low-level details about how the data is stored and interpreted.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**

```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="state_duration_frames" size="4" type="int" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_count_min" size="4" type="int" >
    </Var>
    <Var name="attack_ranged_entity_count_max" size="4" type="int" >
    </Var>
  </Component>
```

This component defines parameters related to an AI's attack behavior. It includes variables for attack probability, range, angles, animation names, and details about ranged attacks such as the entity file to spawn, and the minimum/maximum count of entities to spawn.

**2. `CellEaterComponent`:**

```xml
  <Component component_name="CellEaterComponent" >
    <Var name="radius" size="4" type="float" >
    </Var>
    <Var name="eat_probability" size="4" type="int" >
    </Var>
    <Var name="ignored_material" size="4" type="int" >
    </Var>
    <Var name="materials" size="12" type="class std::vector<int,class std::allocator<int> >" >
    </Var>
  </Component>
```

This component likely governs entities that consume or "eat" surrounding materials. It specifies a `radius` of effect, an `eat_probability`, a material ID to ignore, and a list of `materials` that can be eaten.

**3. `LifetimeComponent`:**

```xml
  <Component component_name="LifetimeComponent" >
    <Var name="lifetime" size="4" type="int" >
    </Var>
    <Var name="randomize_lifetime" size="8" type="struct ValueRange" >
    </Var>
    <Var name="fade_sprites" size="1" type="bool" >
    </Var>
  </Component>
```

This component defines how long an entity or effect persists. It includes a base `lifetime` in frames, a `randomize_lifetime` parameter (likely a range for variation), and a boolean to control whether sprites fade out.

## Reference

This file contains 6624 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/0309172636c2e1914c9b6dea36872672.xml).
---