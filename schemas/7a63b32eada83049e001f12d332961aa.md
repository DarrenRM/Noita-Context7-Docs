---
title: 7a63b32eada83049e001f12d332961aa
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/7a63b32eada83049e001f12d332961aa.xml
---

# 7a63b32eada83049e001f12d332961aa

This XML file defines the structure and data types for various game components within Noita. It acts as a schema, outlining how different game entities and their behaviors are represented in the game's data. This is crucial for understanding how game mechanics are implemented, and for modders who wish to alter or add new functionalities. The file specifies the names, sizes, and types of variables associated with each component, essentially providing a blueprint for the game's internal data representation.

## File Structure

The file is structured as a series of `<Component>` elements, each representing a distinct game component. The root element is `<Schema>`, which contains these components.

Each `<Component>` element has a `component_name` attribute that identifies the specific component (e.g., `AIAttackComponent`, `AIComponent`, `GhostComponent`).

Inside each `<Component>`, there are `<Var>` elements. Each `<Var>` element defines a variable within that component and has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<float>` (a 2D vector of floats).

The structure is hierarchical, with `<Schema>` at the top, containing multiple `<Component>` elements, which in turn contain multiple `<Var>` elements.

## Key Patterns

*   **Component-Based Design:** The game's data is organized around distinct components, each responsible for a specific aspect of an entity's behavior or properties.
*   **Variable Definitions:** Each component's variables are explicitly defined with their name, size, and type, providing a clear schema for data serialization and deserialization.
*   **Data Type Variety:** The file showcases a range of data types, from simple integers and booleans to complex C++ class representations, indicating the sophistication of the game's internal systems.
*   **AI Components:** A significant portion of the defined components appear to be related to Artificial Intelligence (AI), with names like `AIAttackComponent`, `AIComponent`, and `AnimalAIComponent`. These components likely govern enemy behavior, movement, and combat.
*   **Physics and Collision:** Components like `PhysicsBodyCollisionDamageComponent` and `PhysicsBodyComponent` suggest that the game has a robust physics engine, handling collisions, damage, and physical properties of entities.
*   **Entity Properties:** Other components define more general properties of entities, such as `GhostComponent` (for ghost-like entities) and `GodInfoComponent` (potentially related to player or divine powers).

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**
This component defines parameters related to an AI's attack capabilities.
```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_count_min" size="4" type="int" >
    </Var>
  </Component>
```
This sample shows variables controlling attack probability, range, targeting angles, animation names, and parameters for ranged attacks, including the entity file to spawn and the minimum count of entities to spawn.

**2. `AnimalAIComponent`:**
This component seems to define behaviors specific to animal-like AI entities.
```xml
  <Component component_name="AnimalAIComponent" >
    <Var name="ai_state" size="4" type="int" >
    </Var>
    <Var name="preferred_job" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="escape_if_damaged_probability" size="4" type="int" >
    </Var>
    <Var name="attack_if_damaged_probability" size="4" type="int" >
    </Var>
  </Component>
```
Here, we see variables for the AI's current state, a preferred job or behavior, and probabilities for escaping or attacking when damaged.

**3. `GhostComponent`:**
This component defines properties for entities that behave like ghosts.
```xml
  <Component component_name="GhostComponent" >
    <Var name="speed" size="4" type="float" >
    </Var>
    <Var name="velocity" size="8" type="class ceng::math::CVector2<float>" >
    </Var>
    <Var name="aggressiveness" size="4" type="float" >
    </Var>
    <Var name="target_tag" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
  </Component>
```
This sample includes variables for movement speed, velocity, aggressiveness, and a target tag, suggesting how ghosts might hunt or interact with specific entities.

## Reference

This file contains 6820 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/7a63b32eada83049e001f12d332961aa.xml).

---