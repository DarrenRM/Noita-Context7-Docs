---
title: 6cdd2a3099b70eb0377a234770234330
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/6cdd2a3099b70eb0377a234770234330.xml
---

# 6cdd2a3099b70eb0377a234770234330

This XML file defines the schema for various game components and their properties within Noita. It acts as a blueprint, specifying the structure and data types for different game elements, such as AI behaviors, physics properties, and visual components. This schema is crucial for the game engine to correctly interpret and instantiate these components, enabling the complex interactions and behaviors observed in Noita. Modders can use this file to understand how existing components are structured and to create their own custom components or modify existing ones.

## File Structure

The file is structured as a root `<Schema>` element, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute to identify it. Inside each `<Component>`, there are `<Var>` elements, each defining a specific variable or property associated with that component.

Each `<Var>` element has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or custom classes like `class ConfigExplosion` or `class ceng::math::CVector2<float>`.

The structure is hierarchical, with the `<Schema>` at the top, followed by individual `<Component>` definitions, and then the `<Var>` elements detailing the properties within each component.

## Key Patterns

*   **Component-Based Architecture:** The file clearly demonstrates a component-based design, where game entities are composed of various independent components, each responsible for a specific aspect of functionality (e.g., AI, physics, rendering).
*   **Variable Definitions:** Each component's properties are defined using `<Var>` tags, specifying their name, size, and data type. This allows for precise control over data representation.
*   **Data Type Variety:** The file uses a range of data types, from simple integers and floats to complex string types and custom vector classes, reflecting the diverse needs of game development.
*   **AI and Physics Focus:** Several components observed in the samples, such as `AIAttackComponent`, `AIComponent`, `PhysicsRagdollComponent`, and `PhysicsShapeComponent`, indicate a strong emphasis on defining artificial intelligence behaviors and physical interactions.
*   **Visual and Audio Components:** Components like `SpriteComponent` (implied by string types for filenames) and potentially others related to visual effects (e.g., `LightningComponent`) suggest the definition of visual aspects.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**
This component defines parameters related to an entity's attack capabilities.

```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_aim_rotation_enabled" size="1" type="bool" >
    </Var>
    </Var>
  </Component>
```
This snippet shows variables like `use_probability` (an integer), `min_distance` and `max_distance` (floats defining attack range), `animation_name` (a string for the attack animation), and settings for ranged attacks like `attack_ranged_entity_file` and `attack_ranged_aim_rotation_enabled`.

**2. `LightningComponent`:**
This component appears to define properties for lightning-based effects or entities.

```xml
  <Component component_name="LightningComponent" >
    <Var name="config_explosion" size="356" type="class ConfigExplosion" >
    </Var>
    <Var name="sprite_lightning_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="is_projectile" size="1" type="bool" >
    </Var>
    <Var name="explosion_type" size="4" type="int" >
    </Var>
    <Var name="arc_lifetime" size="4" type="int" >
    </Var>
  </Component>
```
Here, we see a `config_explosion` (a complex `ConfigExplosion` object), `sprite_lightning_file` (a string for the sprite asset), `is_projectile` (a boolean), and `explosion_type` and `arc_lifetime` (integers related to the lightning's behavior).

**3. `PhysicsShapeComponent`:**
This component defines the physical shape properties of an entity.

```xml
  <Component component_name="PhysicsShapeComponent" >
    <Var name="recreate" size="1" type="bool" >
    </Var>
    <Var name="is_circle" size="1" type="bool" >
    </Var>
    <Var name="is_box" size="1" type="bool" >
    </Var>
    <Var name="is_capsule" size="1" type="bool" >
    </Var>
    <Var name="is_based_on_sprite" size="1" type="bool" >
    </Var>
  </Component>
```
This component includes boolean flags like `recreate`, `is_circle`, `is_box`, `is_capsule`, and `is_based_on_sprite`, which likely control how the physics shape is defined and updated.

## Reference

This file contains 6236 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/6cdd2a3099b70eb0377a234770234330.xml).
---