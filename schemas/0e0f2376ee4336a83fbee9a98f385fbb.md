---
title: 0e0f2376ee4336a83fbee9a98f385fbb
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/0e0f2376ee4336a83fbee9a98f385fbb.xml
---

# 0e0f2376ee4336a83fbee9a98f385fbb

This file defines the structure and properties of various game components used in Noita. It acts as a schema, outlining the data types and names for attributes that make up different game entities, such as enemies, spells, and environmental objects. By defining these components, the game can systematically load and interpret the data for each element, dictating their behavior, appearance, and interactions. This schema file is crucial for understanding how Noita's game objects are constructed and for modding purposes, as it provides the blueprint for these definitions.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute.

Inside each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual properties or variables within that component. Each `<Var>` has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, `struct ValueRange`, `enum JOINT_TYPE::Enum`).

Some `<Var>` elements may contain nested structures, indicated by `size="8" type="struct ValueRange"` or `size="4" type="enum JOINT_TYPE::Enum"`, suggesting that these variables themselves are composed of further defined data.

```xml
<Schema hash="0e0f2376ee4336a83fbee9a98f385fbb" >
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    ...
  </Component>
  <Component component_name="AIComponent" >
    ...
  </Component>
  ...
</Schema>
```

## Key Patterns

Several patterns are evident in the sampled data:

*   **Component-Based Design:** The game appears to use a component-based architecture, where entities are composed of various functional components (e.g., `AIAttackComponent`, `AIComponent`, `LifetimeComponent`, `LightComponent`, `PhysicsJointComponent`).
*   **Variable Definitions:** Each component is defined by a set of variables, each with a specific name, size, and data type. This allows for granular control over the properties of each component.
*   **Data Types:** A variety of data types are used, including primitive types like integers (`int`), floating-point numbers (`float`), and booleans (`bool`), as well as more complex types like strings (`class std::basic_string<...>`) and custom structures/enums (`struct ValueRange`, `enum JOINT_TYPE::Enum`).
*   **AI and Behavior:** Components like `AIAttackComponent` and `AIComponent` suggest a focus on defining artificial intelligence and combat behaviors for entities. Parameters like `use_probability`, `min_distance`, `angular_range_deg`, and `animation_name` point to complex AI logic.
*   **Physical Properties:** Components like `PhysicsJointComponent` define physical interactions, including joint types, body connections, and breakability.
*   **Temporal and Visual Properties:** `LifetimeComponent` and `LightComponent` define how long entities persist and their visual lighting characteristics, respectively.
*   **Biological/Consumable Properties:** The sample from lines 553-603 shows variables related to food, eating, and bodily functions (`food_material`, `food_particle_effect_material`, `defecates_and_pees`, `pee_velocity_x`), indicating components that manage biological aspects of entities.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`:** This component defines the parameters for an entity's attack capabilities.
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      ...
    </Component>
    ```
    This component includes variables for attack range, probability of use, and specific parameters for ranged attacks, such as the entity file to spawn and aiming behavior.

2.  **`LifetimeComponent`:** This component governs how long an entity exists in the game world.
    ```xml
    <Component component_name="LifetimeComponent" >
      <Var name="lifetime" size="4" type="int" >
      </Var>
      <Var name="randomize_lifetime" size="8" type="struct ValueRange" >
      </Var>
    </Component>
    ```
    It defines a base `lifetime` in frames and allows for randomization of this duration using a `ValueRange` structure.

3.  **`PhysicsJointComponent`:** This component describes physical joints connecting different parts of an entity or objects in the environment.
    ```xml
    <Component component_name="PhysicsJointComponent" >
      <Var name="nail_to_wall" size="1" type="bool" >
      </Var>
      <Var name="grid_joint" size="1" type="bool" >
      </Var>
      <Var name="breakable" size="1" type="bool" >
      </Var>
      <Var name="type" size="4" type="enum JOINT_TYPE::Enum" >
      </Var>
      <Var name="body1_id" size="4" type="int" >
      </Var>
      <Var name="body2_id" size="4" type="int" >
      </Var>
      ...
    </Component>
    ```
    This component specifies whether a joint can be nailed to a wall, is a grid-based joint, is breakable, its type, and the IDs of the two bodies it connects.

## Reference

This file contains 6312 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/0e0f2376ee4336a83fbee9a98f385fbb.xml).

---