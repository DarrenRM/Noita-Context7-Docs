---
title: 5e20ac4b8640ed49b157b932c33f5041
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/5e20ac4b8640ed49b157b932c33f5041.xml
---

# 5e20ac4b8640ed49b157b932c33f5041

This file defines the structure and properties of various game components used within Noita. It acts as a schema, outlining the data types and names for attributes that make up different game entities and their behaviors. Essentially, it's a blueprint for how game objects are configured, allowing for a wide range of customization and complexity in the game's world. This schema file is crucial for understanding how different game mechanics are implemented and for modding purposes.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute. Inside each `<Component>`, there are `<Var>` elements, each defining a variable or property associated with that component.

Each `<Var>` element has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<float>` (representing a 2D vector of floats).

The structure follows a clear pattern:
```xml
<Schema hash="...">
  <Component component_name="...">
    <Var name="..." size="..." type="...">
    </Var>
    <Var name="..." size="..." type="...">
    </Var>
    ...
  </Component>
  <Component component_name="...">
    ...
  </Component>
  ...
</Schema>
```

## Key Patterns

Several patterns and categories of components are evident from the sampled data:

*   **AI Components:** Components related to artificial intelligence and enemy behavior are prominent. Examples include `AIAttackComponent` and `AIComponent`. These define how entities perceive, react, and attack.
*   **Physics and Collision:** Components dealing with the physical properties of entities are present, such as `PhysicsRagdollComponent` and `PhysicsShapeComponent`. These likely govern how objects interact with the environment and each other.
*   **Visual and Audio:** Components related to visual effects and sound are also defined, like `AudioComponent`.
*   **Gameplay Mechanics:** Various components define specific gameplay mechanics, such as `DamageComponent`, `ElectricitySourceComponent`, and `EnergyShieldComponent`.
*   **Data Types:** A mix of primitive C++ data types (`int`, `float`, `bool`) and more complex object types (strings, vectors) are used, indicating a structured and object-oriented approach to game data.
*   **Component Naming Convention:** Component names are descriptive and often use CamelCase, clearly indicating their purpose (e.g., `AIAttackComponent`, `EnergyShieldComponent`).

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**:
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      ...
    </Component>
    ```
    This component defines parameters for an entity's attack capabilities, including probabilities, distances, angles, animation names, and details about ranged attacks like the entity file to spawn.

2.  **`DamageComponent`**:
    ```xml
    <Var name="damage_type" size="4" type="enum DAMAGE_TYPES::Enum" >
    </Var>
    <Var name="damage_per_frame" size="4" type="float" >
    </Var>
    <Var name="death_cause" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    ...
    ```
    This snippet, likely part of a larger component, defines how damage is applied. It includes the type of damage, the amount of damage per frame, and the string identifier for the cause of death.

3.  **`PhysicsShapeComponent`**:
    ```xml
    <Component component_name="PhysicsShapeComponent" >
      <Var name="recreate" size="1" type="bool" >
      </Var>
      <Var name="is_circle" size="1" type="bool" >
      </Var>
      <Var name="is_box" size="1" type="bool" >
      </Var>
      <Var name="is_capsule" size="1" type="bool" >
      </Var>
      <Var name="is_based_on_sprite" size="1" type="bool" >
      </Var>
      <Var name="friction" size="4" type="float" >
      </Var>
    </Component>
    ```
    This component describes the physical shape of an entity for collision and physics simulation. It includes boolean flags to define the shape type (circle, box, capsule, sprite-based) and a `friction` property.

## Reference

This file contains 6792 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/5e20ac4b8640ed49b157b932c33f5041.xml).

---