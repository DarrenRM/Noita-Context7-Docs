---
title: db1d7648d67870a8afcc738caa895dae
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/db1d7648d67870a8afcc738caa895dae.xml
---

# db1d7648d67870a8afcc738caa895dae

This XML file defines the structure and properties of various game components used in Noita. It acts as a schema or blueprint, detailing the data types, sizes, and names of variables associated with each component. These components are fundamental building blocks for entities within the game, dictating their behavior, appearance, and interactions. By defining these components in a structured format, Noita can efficiently load and manage game data, allowing for complex entity designs and behaviors. This file is crucial for understanding how different game elements are constructed and how they function.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct game component and has a `component_name` attribute to identify it.

Inside each `<Component>`, there are `<Var>` elements. Each `<Var>` element defines a specific variable or property of that component. These `<Var>` elements have the following attributes:

*   **`name`**: The name of the variable (e.g., `use_probability`, `min_distance`).
*   **`size`**: The size of the variable in bytes. This often corresponds to the data type.
*   **`type`**: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class std::vector<int,class std::allocator<int> >` (a vector of integers).

The structure is hierarchical: `Schema` -> `Component` -> `Var`.

## Key Patterns

*   **Component-Based Design**: The file clearly follows a component-based architecture, where game entities are composed of various functional components.
*   **Variable Definition**: Each `<Var>` tag meticulously defines a single property of a component, including its name, size, and data type. This allows for precise data serialization and deserialization.
*   **Data Type Representation**: The `type` attribute uses C++-like type names, indicating the underlying implementation language of the game. This provides insight into how data is stored and manipulated.
*   **Categorization by Component**: Components are grouped logically, such as AI-related components (`AIAttackComponent`, `AIComponent`), movement components (`CardinalMovementComponent`), and physics-related components (`PhysicsPickUpComponent`, `PhysicsRagdollComponent`).
*   **Attribute Usage**: Attributes like `size` and `type` are consistently used to describe the data associated with each variable.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**:
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
    </Component>
    ```
    This component appears to define the parameters for an AI's attack capabilities. It includes variables for attack probability, range, animation names, and the entity file used for ranged attacks.

2.  **`CellEaterComponent`**:
    ```xml
    <Component component_name="CellEaterComponent" >
      <Var name="radius" size="4" type="float" >
      </Var>
      <Var name="eat_probability" size="4" type="int" >
      </Var>
      <Var name="materials" size="12" type="class std::vector<int,class std::allocator<int> >" >
      </Var>
    </Component>
    ```
    This component seems to govern entities that can "eat" or consume cells. It defines the radius of consumption, the probability of eating, and a list of materials that can be eaten.

3.  **`PhysicsPickUpComponent`**:
    ```xml
    <Component component_name="PhysicsPickUpComponent" >
      <Var name="transform" size="32" type="struct ceng::math::CXForm<float>" >
      </Var>
      <Var name="pick_up_strength" size="4" type="float" >
      </Var>
    </Component>
    ```
    This component is related to physics and pickup mechanics. It includes a `transform` variable (likely for position and orientation) and `pick_up_strength`, suggesting how strongly an entity can pick up other objects.

## Reference

This file contains 6272 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/db1d7648d67870a8afcc738caa895dae.xml).

---