---
title: 7198be5a2ef5b119ed7ed46d0cac7323
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/7198be5a2ef5b119ed7ed46d0cac7323.xml
---

# 7198be5a2ef5b119ed7ed46d0cac7323

This XML file defines the structure and properties of various game components used in Noita. It acts as a schema, outlining the data types and names for variables within different game entities. These components likely govern the behavior, appearance, and interactions of everything from enemies and items to environmental elements and player abilities. By defining these components, the game can systematically load and manage the vast array of game objects and their associated logic.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct type of game component. The root element `<Schema>` contains these components and is identified by a `hash` attribute.

Each `<Component>` element has a `component_name` attribute that clearly identifies its purpose. Inside each component, there are `<Var>` elements, which define individual variables or properties.

Each `<Var>` element has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, `struct LensValue<float>`, `class ceng::math::CVector2<float>`).

The content within a `<Var>` tag is typically empty, indicating that the definition is purely structural.

## Key Patterns

*   **Component-Based Architecture:** The file clearly demonstrates a component-based design, where game entities are composed of various reusable components.
*   **Variable Definitions:** Each component is broken down into its constituent variables, with explicit type and size information. This suggests a low-level data representation.
*   **String Representation:** String types are represented using a verbose C++-like class name: `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`.
*   **Vector Types:** Vector data, such as positions, are represented by custom class types like `class ceng::math::CVector2<float>`.
*   **Structs with Generics:** Some variables use generic struct types like `struct LensValue<float>`, which likely encapsulate values with additional metadata or functionality.
*   **Boolean Flags:** Many variables are booleans (`size="1" type="bool"`), used for enabling or disabling specific behaviors or properties.
*   **Numerical Properties:** Integers (`int`) and floating-point numbers (`float`) are used extensively for numerical values like distances, durations, probabilities, and forces.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**
This component defines parameters related to an AI's attack capabilities.
```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
  </Component>
```
This shows how an AI's attack can be configured with probabilities, ranges, and specific projectile or effect entity files.

**2. `AltarComponent`:**
This component defines properties for altars in the game.
```xml
  <Component component_name="AltarComponent" >
    <Var name="recognized_entity_tags" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="good_fx_material" size="4" type="int" >
    </Var>
    <Var name="uses_remaining" size="4" type="int" >
    </Var>
  </Component>
```
This indicates that altars can recognize specific entity tags, have associated visual effects (FX materials), and a limited number of uses.

**3. `ItemRechargeNearGroundComponent`:**
This component seems to be related to items that recharge when near the ground.
```xml
  <Component component_name="ItemRechargeNearGroundComponent" >
    <Var name="TEMP_TEMPY" size="4" type="float" >
    </Var>
    <Var name="TEMP_TEMP_TEMP" size="4" type="float" >
    </Var>
  </Component>
```
The variable names here (`TEMP_TEMPY`, `TEMP_TEMP_TEMP`) are placeholders or internal debugging names, suggesting that the exact functionality might be more complex or less directly exposed in this schema.

**4. Physics-related properties within an unnamed component:**
This sample shows several boolean flags related to the physical properties of an entity.
```xml
    <Var name="allow_sleep" size="1" type="bool" >
    </Var>
    <Var name="fixed_rotation" size="1" type="bool" >
    </Var>
    <Var name="buoyancy" size="4" type="float" >
    </Var>
    <Var name="is_bullet" size="1" type="bool" >
    </Var>
    <Var name="is_static" size="1" type="bool" >
    </Var>
    <Var name="is_kinematic" size="1" type="bool" >
    </Var>
    <Var name="is_character" size="1" type="bool" >
    </Var>
    <Var name="go_through_sand" size="1" type="bool" >
    </Var>
```
These flags control how an entity interacts with the game's physics engine, such as whether it can sleep, has a fixed rotation, or can pass through certain materials.

## Reference

This file contains 6320 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/7198be5a2ef5b119ed7ed46d0cac7323.xml).

---