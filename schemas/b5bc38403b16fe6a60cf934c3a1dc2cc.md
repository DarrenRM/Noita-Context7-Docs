---
title: b5bc38403b16fe6a60cf934c3a1dc2cc
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/b5bc38403b16fe6a60cf934c3a1dc2cc.xml
---

# b5bc38403b16fe6a60cf934c3a1dc2cc

This XML file defines the structure and properties of various game components used in Noita. It acts as a schema, outlining the data types and names for variables within different game systems. These components are likely used to define the behavior, attributes, and functionalities of entities, enemies, spells, and other game elements. By defining these components in a structured format, Noita can efficiently load and manage game data, allowing for complex interactions and behaviors.

## File Structure

The file is structured as a series of `<Component>` elements, each representing a distinct game component. The root element `<Schema>` contains these components and is identified by a `hash` attribute.

Each `<Component>` element has a `component_name` attribute that clearly identifies the purpose of the component (e.g., `AIAttackComponent`, `AIComponent`, `CharacterCollisionComponent`).

Inside each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual variables within that component. Each `<Var>` has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or custom struct types like `struct LensValue<float>` and `struct ValueRangeInt`.

The structure is hierarchical: `<Schema>` contains `<Component>`s, and `<Component>`s contain `<Var>`s.

## Key Patterns

*   **Component-Based Design:** The file clearly follows a component-based architecture, where different functionalities are encapsulated into distinct components.
*   **Variable Definitions:** Each component's variables are explicitly defined with their names, sizes, and types, providing a blueprint for how data should be structured.
*   **Data Type Variety:** The file showcases a range of data types, from simple booleans and integers to complex string representations and custom structs, indicating the depth of Noita's data management.
*   **Naming Conventions:** Component and variable names are generally descriptive, hinting at their in-game purpose (e.g., `use_probability`, `min_distance`, `animation_name`, `collision_aabb_min_x`).
*   **String Representation:** The common use of `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` for string types suggests that string data is handled using C++'s standard string library.
*   **Struct Usage:** The presence of structs like `struct LensValue<float>`, `struct ValueRangeInt`, and `struct types::iaabb` indicates that Noita uses custom data structures to group related variables or define specific value ranges and geometric properties.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent`:**
This component appears to define the parameters for an AI's attack behavior.
```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_count_min" size="4" type="int" >
    </Var>
  </Component>
```
This sample shows variables controlling attack probability, range, aiming, animation, and the specific entity file to spawn for ranged attacks, along with its count.

**2. `CharacterCollisionComponent`:**
This component seems to define properties related to character collision and physics.
```xml
  <Component component_name="CharacterCollisionComponent" >
    <Var name="getting_crushed_threshold" size="4" type="int" >
    </Var>
    <Var name="moving_up_before_getting_crushed_threshold" size="4" type="int" >
    </Var>
  </Component>
```
Here, variables like `getting_crushed_threshold` suggest how the game determines when a character is crushed by environmental forces.

**3. `LiquidDisplacerComponent`:**
This component likely governs how entities interact with and displace liquids.
```xml
  <Component component_name="LiquidDisplacerComponent" >
    <Var name="radius" size="4" type="int" >
    </Var>
    <Var name="velocity_x" size="4" type="float" >
    </Var>
    <Var name="velocity_y" size="4" type="float" >
    </Var>
  </Component>
```
This shows parameters for the displacement radius and the velocity components affecting the liquid.

## Reference

This file contains 6848 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/b5bc38403b16fe6a60cf934c3a1dc2cc.xml).

---