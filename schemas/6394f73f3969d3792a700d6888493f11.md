---
title: 6394f73f3969d3792a700d6888493f11
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/6394f73f3969d3792a700d6888493f11.xml
---

# 6394f73f3969d3792a700d6888493f11

This XML file defines the schema for various game components and their associated variables in Noita. It acts as a blueprint, outlining the structure and data types for different game entities and their behaviors. This schema is crucial for the game engine to correctly interpret and load data related to entities, their properties, and their interactions. Understanding this schema is essential for anyone looking to delve into Noita's data files, including modders who wish to modify or add new game content.

## File Structure

The file is structured as a series of `<Component>` elements, each representing a distinct game component. Within each `<Component>`, there are `<Var>` elements that define individual variables associated with that component.

*   **`<Schema>`:** The root element, containing a `hash` attribute that likely identifies this specific schema definition.
*   **`<Component>`:** Represents a specific game component. It has a `component_name` attribute that names the component (e.g., `AIAttackComponent`, `AIComponent`, `CellEaterComponent`).
*   **`<Var>`:** Defines a variable within a component. Each `<Var>` has the following attributes:
    *   `name`: The name of the variable (e.g., `use_probability`, `radius`, `causing_status_effect`).
    *   `size`: The size of the variable in bytes.
    *   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (string) and `class std::vector<...>` (vector).

The overall structure is a hierarchical definition of components and their properties, allowing for a modular and organized way to define game logic and data.

## Key Patterns

Several patterns are evident in the sampled content:

*   **Component-Based Design:** The game appears to be built around a component system, where entities are composed of various functional components. This is reflected in the `<Component>` tags.
*   **Variable Definitions:** Each component is described by a set of `<Var>` tags, detailing its configurable parameters.
*   **Data Type Variety:** The `type` attribute of `<Var>` shows a range of data types, from simple booleans and integers to complex string and vector types, indicating the richness of data that can be stored.
*   **Naming Conventions:** Variable names are generally descriptive, hinting at their purpose (e.g., `min_distance`, `eat_probability`, `can_jump`).
*   **Boolean Flags:** Many variables are of type `bool`, serving as toggles for various features or behaviors (e.g., `attack_landing_ranged_enabled`, `only_stain`, `mInvisible`).
*   **Numerical Parameters:** `int` and `float` types are used extensively for numerical values like distances, speeds, probabilities, and durations.
*   **String Identifiers:** `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` is used for string values, likely for names of animations, entity files, or status effects.
*   **Collections:** `class std::vector<...>` indicates that components can hold collections of data, such as lists of materials or jump parameters.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`:**
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_aim_rotation_enabled" size="1" type="bool" >
      </Var>
    </Component>
    ```
    This component likely defines how an AI entity attacks. It includes variables for attack probability, range (`min_distance`, `max_distance`), animation names, and parameters for ranged attacks, such as the entity file to spawn (`attack_ranged_entity_file`) and whether aiming rotation is enabled (`attack_ranged_aim_rotation_enabled`).

2.  **`CellEaterComponent`:**
    ```xml
    <Component component_name="CellEaterComponent" >
      <Var name="radius" size="4" type="float" >
      </Var>
      <Var name="eat_probability" size="4" type="int" >
      </Var>
      <Var name="ignored_material" size="4" type="int" >
      </Var>
      <Var name="materials" size="12" type="class std::vector<int,class std::allocator<int> >" >
      </Var>
    </Component>
    ```
    This component seems to govern entities that consume or "eat" certain materials. It defines the `radius` of consumption, the `eat_probability`, materials to be `ignored_material`, and a list of specific `materials` that can be consumed.

3.  **`PathfindingComponent` (implied by `jump_trajectories`):**
    ```xml
    <Component component_name="PathfindingComponent" >
      <Var name="can_jump" size="1" type="bool" >
      </Var>
      <Var name="jump_speed" size="4" type="float" >
      </Var>
      <Var name="jump_trajectories" size="12" type="class std::vector<struct PathFindingJumpParams,class std::allocator<struct PathFindingJumpParams> >" >
      </Var>
    </Component>
    ```
    This component appears to be related to entity movement and pathfinding. It includes flags for whether jumping is possible (`can_jump`), the speed of jumps (`jump_speed`), and a complex vector (`jump_trajectories`) that likely stores parameters for different jump behaviors.

## Reference

This file contains 7064 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/6394f73f3969d3792a700d6888493f11.xml).

---