---
title: d9fcdae57b0022cd77e6d62bde535be7
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/d9fcdae57b0022cd77e6d62bde535be7.xml
---

# d9fcdae57b0022cd77e6d62bde535be7

This XML file defines the structure and properties of various game components used in Noita. It acts as a schema, outlining the data types and names for variables within different game systems. These components are fundamental building blocks for entities, behaviors, and game mechanics, dictating how enemies act, how objects interact, and how visual elements are rendered. Understanding this schema is crucial for comprehending the underlying data that drives Noita's complex simulation.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct game component. The root element `<Schema>` contains these components.

Each `<Component>` element has a `component_name` attribute that uniquely identifies the component (e.g., `AIAttackComponent`, `AIComponent`, `DebugSpatialVisualizerComponent`).

Inside each `<Component>`, there are multiple `<Var>` elements. These `<Var>` elements define individual variables within that component. Each `<Var>` has the following attributes:

*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` which represents a string).

The `<Var>` elements themselves are typically empty, as their purpose is to define the structure and metadata of the variables, not to hold actual values.

## Key Patterns

*   **Component-Based Architecture:** The file clearly demonstrates Noita's use of a component-based entity system. Each `<Component>` represents a self-contained piece of functionality that can be attached to game entities.
*   **Variable Definitions:** The `<Var>` tags are consistently used to define the properties of each component, specifying their names, sizes, and data types.
*   **String Representation:** String types are represented by a verbose C++-like type: `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`. This often indicates file paths or names of other game assets.
*   **Numerical Types:** Common numerical types like `int` (integer) and `float` (floating-point number) are used extensively for values like distances, speeds, durations, and probabilities.
*   **Boolean Flags:** `bool` (boolean) types are used for simple on/off states or flags.
*   **Categorization by Functionality:** Components are named descriptively, allowing for easy categorization of their purpose. For example, `AIAttackComponent` clearly relates to AI attacking, while `DebugSpatialVisualizerComponent` suggests visualization for debugging.
*   **Scripting Hooks:** Several components, particularly those related to events or interactions, define string variables that likely serve as hooks for custom scripting. Examples include `script_damage_about_to_be_received` and `script_item_picked_up`.

## Sample Entries

**1. `AIAttackComponent` (from the first 100 lines):**

```xml
  <Component component_name="AIAttackComponent" >
    <Var name="use_probability" size="4" type="int" >
    </Var>
    <Var name="min_distance" size="4" type="float" >
    </Var>
    <Var name="max_distance" size="4" type="float" >
    </Var>
    <Var name="angular_range_deg" size="4" type="float" >
    </Var>
    <Var name="state_duration_frames" size="4" type="int" >
    </Var>
    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="attack_ranged_entity_count_min" size="4" type="int" >
    </Var>
    <Var name="attack_ranged_entity_count_max" size="4" type="int" >
    </Var>
    <Var name="attack_ranged_use_laser_sight" size="1" type="bool" >
    </Var>
    <Var name="attack_ranged_aim_rotation_enabled" size="1" type="bool" >
    </Var>
    <Var name="attack_ranged_aim_rotation_speed" size="4" type="float" >
    </Var>
    <Var name="attack_ranged_aim_rotation_shooting_ok_angle_deg" size="4" type="float" >
    </Var>
  </Component>
```

This component defines parameters for an AI's attacking behavior. It includes variables for attack range (`min_distance`, `max_distance`), accuracy (`angular_range_deg`), timing (`state_duration_frames`, `frames_between`), animation (`animation_name`), and specific properties for ranged attacks like the entity file to spawn (`attack_ranged_entity_file`), count limits, and aiming mechanics.

**2. `AIComponent` (from sample lines 897-947):**

```xml
    <Var name="eat_ground" size="1" type="bool" >
    </Var>
    <Var name="hitbox_radius" size="4" type="float" >
    </Var>
    <Var name="bite_damage" size="4" type="float" >
    </Var>
    <Var name="target_kill_radius" size="4" type="float" >
    </Var>
    <Var name="hunt_box_radius" size="4" type="float" >
    </Var>
    <Var name="random_target_box_radius" size="4" type="float" >
    </Var>
    <Var name="new_hunt_target_check_every" size="4" type="int" >
    </Var>
    <Var name="projectile_1" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
```

This sample from the `AIComponent` shows variables related to an AI's general behavior and targeting. It includes parameters for eating ground, hitbox size, bite damage, and various radii and intervals for hunting and finding random targets. The `projectile_1` variable likely refers to a projectile entity used by this AI.

**3. `ScriptingComponent` (from sample lines 3536-3586):**

```xml
    <Var name="script_damage_about_to_be_received" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_item_picked_up" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_shot" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_collision_trigger_hit" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
    <Var name="script_death" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This section from a `ScriptingComponent` (inferred from the variable names) highlights how game events can trigger custom scripts. Each `script_` prefixed variable is a string, likely pointing to a Lua script file that will be executed when the corresponding event occurs (e.g., when an entity receives damage, picks up an item, or dies).

## Reference

This file contains 6876 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/d9fcdae57b0022cd77e6d62bde535be7.xml).

---