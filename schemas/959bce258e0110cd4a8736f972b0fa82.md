---
title: 959bce258e0110cd4a8736f972b0fa82
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/959bce258e0110cd4a8736f972b0fa82.xml
---

# 959bce258e0110cd4a8736f972b0fa82

This XML file defines the structure and data types for various game components in Noita. It acts as a schema, outlining how different game entities and their behaviors are represented in the game's data files. These definitions are crucial for the game engine to correctly load, interpret, and utilize the properties of objects, enemies, spells, and other game elements. Essentially, it's a blueprint for how game data is organized.

## File Structure

The file is structured as an XML document with a root `<Schema>` element. Inside this, various `<Component>` elements are defined. Each `<Component>` represents a distinct type of game logic or property that can be attached to game entities.

Within each `<Component>`, there are `<Var>` elements. These `<Var>` elements define individual variables or properties associated with that component. Each `<Var>` has the following attributes:

*   **`name`**: The identifier for the variable (e.g., `use_probability`, `min_distance`).
*   **`size`**: The size of the variable in bytes. This often indicates the data type.
*   **`type`**: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` which represents a string).

The structure is hierarchical: `Schema` -> `Component` -> `Var`.

## Key Patterns

*   **Component-Based Architecture**: The file clearly demonstrates a component-based design for game entities. Different functionalities (AI, attacks, movement, visual effects) are encapsulated in separate components.
*   **Variable Definitions**: Each component's properties are defined as individual variables with explicit type and size information. This allows for precise data serialization and deserialization.
*   **Naming Conventions**: Variable names are generally descriptive, often using camelCase or snake\_case, and frequently include prefixes like `attack_ranged_` to indicate specific functionalities.
*   **Data Types**: A variety of standard C++ data types are used, including integers (`int`, `unsigned int`), floating-point numbers (`float`), booleans (`bool`), and strings (`class std::basic_string...`). Enums are also present, indicated by types like `enum MOVETOSURFACE_TYPE::Enum`.
*   **AI and Attack Components**: A significant portion of the sampled data relates to AI behavior and attack mechanisms, suggesting these are complex and highly configurable aspects of the game. This includes parameters for attack range, timing, projectile spawning, and aiming.
*   **Material and Physics Components**: Components like `MaterialSuckerComponent` and `DieIfSpeedBelowComponent` indicate definitions for how entities interact with the game world's materials and physics.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**:
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="state_duration_frames" size="4" type="int" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_count_min" size="4" type="int" >
      </Var>
      <Var name="attack_ranged_entity_count_max" size="4" type="int" >
      </Var>
      <Var name="attack_ranged_use_laser_sight" size="1" type="bool" >
      </Var>
      <Var name="attack_ranged_aim_rotation_enabled" size="1" type="bool" >
      </Var>
      <Var name="attack_ranged_aim_rotation_speed" size="4" type="float" >
      </Var>
      <Var name="attack_ranged_aim_rotation_shooting_ok_angle_deg" size="4" type="float" >
      </Var>
    </Component>
    ```
    This component defines parameters for an AI's attack behavior. It includes variables for the probability of attacking, the range of the attack, the duration of attack states, and specific settings for ranged attacks such as the entity file to spawn, count limits, and aiming behavior.

2.  **`DebugSpatialVisualizerComponent`**:
    ```xml
    <Component component_name="DebugSpatialVisualizerComponent" >
      <Var name="min_x" size="4" type="float" >
      </Var>
      <Var name="min_y" size="4" type="float" >
      </Var>
      <Var name="max_x" size="4" type="float" >
      </Var>
      <Var name="max_y" size="4" type="float" >
      </Var>
      <Var name="color" size="4" type="unsigned int" >
      </Var>
    </Component>
    ```
    This component appears to be for debugging purposes, allowing developers to visualize spatial areas. It defines minimum and maximum X and Y coordinates, along with a color attribute, likely to draw bounding boxes or other visual aids in the game world.

3.  **`MaterialSuckerComponent`**:
    ```xml
    <Component component_name="MaterialSuckerComponent" >
      <Var name="material_type" size="4" type="int" >
      </Var>
      <Var name="barrel_size" size="4" type="int" >
      </Var>
      <Var name="num_cells_sucked_per_frame" size="4" type="int" >
      </Var>
      <Var name="set_projectile_to_liquid" size="1" type="bool" >
      </Var>
      <Var name="suck_gold" size="1" type="bool" >
      </Var>
    </Component>
    ```
    This component defines the behavior of an entity that can "suck" or absorb materials. It specifies the type of material to target, the size of the "sucking" mechanism, how many units are absorbed per frame, and whether absorbed materials should become liquids or if gold should be specifically targeted.

## Reference

This file contains 6096 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/959bce258e0110cd4a8736f972b0fa82.xml).

---