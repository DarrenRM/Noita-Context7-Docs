---
title: 850cb4d18f9127afd219612e5cd4c2de
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/850cb4d18f9127afd219612e5cd4c2de.xml
---

# 850cb4d18f9127afd219612e5cd4c2de

This XML file defines the structure and properties of various game components used in Noita. These components are the building blocks for entities, defining their behaviors, attributes, and interactions within the game world. This schema file acts as a blueprint, specifying the types and names of variables that each component can have, allowing the game engine to correctly load and interpret entity data. Understanding this file is crucial for anyone looking to deeply analyze or modify Noita's game mechanics.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct type of game component. The root element `<Schema>` contains these components.

Each `<Component>` element has a `component_name` attribute that uniquely identifies the type of component (e.g., `AIAttackComponent`, `AIComponent`, `LightningComponent`).

Inside each `<Component>`, there are `<Var>` elements. These `<Var>` elements define the individual properties or variables that belong to that component. Each `<Var>` has the following attributes:

*   **`name`**: The name of the variable (e.g., `use_probability`, `min_distance`, `sprite_lightning_file`).
*   **`size`**: The size of the variable in bytes. This can vary depending on the data type.
*   **`type`**: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or custom class types like `class ConfigExplosion`.

The `<Var>` elements themselves are typically empty, as their definition is contained within their attributes.

## Key Patterns

*   **Component-Based Architecture**: The file clearly demonstrates a component-based design, where different functionalities are encapsulated into distinct components.
*   **Variable Definitions**: Each component is defined by a set of variables, each with a specific name, size, and type. This allows for granular control over entity properties.
*   **Data Types**: A variety of data types are used, from simple booleans and integers to floats and complex string types. Custom class types are also referenced, indicating that some components might aggregate other complex data structures.
*   **Naming Conventions**: Variable names are descriptive and often follow a camelCase or snake_case convention, providing clues about their purpose. For example, `attack_ranged_offset_x` clearly indicates an X-axis offset for a ranged attack.
*   **AI and Behavior Components**: Several components appear to be related to Artificial Intelligence and entity behavior, such as `AIAttackComponent`, `AIComponent`, and `MoveToSurfaceOnCreateComponent`.
*   **Visual and Effect Components**: Components like `LightningComponent` suggest definitions for visual effects and environmental interactions.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This snippet shows variables related to an AI's attack capabilities. `use_probability` (an integer) likely controls how often an attack is used, `min_distance` and `max_distance` (floats) define the effective range, `animation_name` (a string) specifies the animation to play during an attack, and `attack_ranged_entity_file` (a string) points to the entity file used for ranged attacks.

**2. `AIComponent` Variables (partial):**

```xml
    <Var name="item_recoil_recovery_speed" size="4" type="float" >
    </Var>

    <Var name="throw_as_item" size="1" type="bool" >
    </Var>

    <Var name="max_amount_in_inventory" size="4" type="int" >
    </Var>
```

This shows variables associated with an `AIComponent`. `item_recoil_recovery_speed` (a float) might relate to how quickly an AI can recover from using an item, `throw_as_item` (a boolean) indicates if an item can be thrown, and `max_amount_in_inventory` (an integer) sets a limit on how many of a particular item an AI can hold.

**3. `LightningComponent` Variables:**

```xml
  <Component component_name="LightningComponent" >

    <Var name="config_explosion" size="356" type="class ConfigExplosion" >

    </Var>

    <Var name="sprite_lightning_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >

    </Var>

    <Var name="arc_lifetime" size="4" type="int" >

    </Var>

  </Component>
```

This component defines properties for lightning effects. `config_explosion` (a `ConfigExplosion` object) likely holds detailed parameters for any associated explosions, `sprite_lightning_file` (a string) points to the sprite asset for the lightning, and `arc_lifetime` (an integer) determines how long a lightning arc persists.

## Reference

This file contains 6116 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/850cb4d18f9127afd219612e5cd4c2de.xml).

---