---
title: 242822a10e3648f2e52aad03f9d1a3b4
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/242822a10e3648f2e52aad03f9d1a3b4.xml
---

# 242822a10e3648f2e52aad03f9d1a3b4

This XML file defines the structure and data types for various game components within Noita. It acts as a schema, outlining how different game mechanics, behaviors, and properties are represented in the game's data. This is crucial for understanding how entities, spells, enemies, and other game elements are configured and how they interact. Modders can use this file to understand the underlying data structures and potentially modify them to alter game behavior.

## File Structure

The file is structured as a series of `<Component>` elements, each representing a distinct game component. These components are then further defined by `<Var>` elements, which specify individual variables or properties within that component.

*   **`<Schema>`:** The root element, containing a `hash` attribute.
*   **`<Component>`:** Represents a specific game component. It has a `component_name` attribute that identifies the component (e.g., `AIAttackComponent`, `AIComponent`, `ControlsComponent`).
*   **`<Var>`:** Defines a variable within a component. Each `<Var>` element has the following attributes:
    *   `name`: The name of the variable (e.g., `use_probability`, `min_distance`, `enabled`).
    *   `size`: The size of the variable in bytes.
    *   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class ceng::math::CVector2<float>` (representing a 2D vector of floats).

The structure is hierarchical: a `<Schema>` contains multiple `<Component>`s, and each `<Component>` contains multiple `<Var>`s.

## Key Patterns

Several patterns are evident in the sampled data:

*   **Component-Based Design:** The game appears to use a component-based architecture, where entities are composed of various functional components. This file defines the parameters for these components.
*   **Variable Types:** A mix of primitive data types (`int`, `float`, `bool`) and more complex C++ types are used, indicating a sophisticated underlying engine.
*   **Naming Conventions:** Variable names are generally descriptive, hinting at their purpose (e.g., `attack_ranged_enabled`, `fire_damage_amount`, `go_through_sand`).
*   **Boolean Flags:** Many variables are booleans (`type="bool"`) used to enable or disable specific behaviors or features (e.g., `attack_ranged_use_message`, `randomize_init_velocity`).
*   **Numerical Parameters:** Many variables are integers or floats, used for controlling values like probabilities, distances, durations, and damage.
*   **String Parameters:** String types are used for names, such as `animation_name` or `attack_ranged_entity_file`, likely referencing other game assets.
*   **Vector Types:** `CVector2<float>` suggests that positional data or directional vectors are common.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This snippet from the `AIAttackComponent` shows how an AI's attack behavior is defined. `use_probability` likely controls how often this attack is chosen, `min_distance` and `max_distance` define its effective range, and `animation_name` specifies the visual animation associated with the attack.

**2. `ControlsComponent` Variables:**

```xml
  <Component component_name="ControlsComponent" >

    <Var name="polymorph_hax" size="1" type="bool" >
    </Var>

    <Var name="enabled" size="1" type="bool" >
    </Var>

    <Var name="gamepad_indirect_aiming_enabled" size="1" type="bool" >
    </Var>
```

This section from the `ControlsComponent` illustrates input and control-related settings. `polymorph_hax` might be a debug or special ability flag, `enabled` likely toggles the component's functionality, and `gamepad_indirect_aiming_enabled` controls a specific aiming mode for gamepads.

**3. `DamageNearbyEntitiesComponent` Variables:**

```xml
  <Component component_name="DamageNearbyEntitiesComponent" >

    <Var name="radius" size="4" type="float" >
    </Var>

    <Var name="damage_min" size="4" type="float" >
    </Var>

    <Var name="damage_max" size="4" type="float" >
    </Var>
```

This excerpt from `DamageNearbyEntitiesComponent` defines parameters for an area-of-effect damage component. `radius` sets the area of effect, while `damage_min` and `damage_max` define the range of damage dealt to entities within that radius.

## Reference

This file contains 6272 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/242822a10e3648f2e52aad03f9d1a3b4.xml).

---