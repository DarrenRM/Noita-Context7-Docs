---
title: 48856b5bc6bd8930b95f24a69a069c0c
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/48856b5bc6bd8930b95f24a69a069c0c.xml
---

# 48856b5bc6bd8930b95f24a69a069c0c

This XML file defines the schema for various game components in Noita. It acts as a blueprint, specifying the structure and data types for different game entities and their behaviors. These schemas are crucial for the game's engine to correctly interpret and load entity data, influencing everything from enemy AI and projectile behavior to material properties and world generation. Understanding these schemas is fundamental for anyone looking to deeply analyze or modify Noita's game data.

## File Structure

The file is structured as a series of `<Component>` elements, each representing a distinct set of properties and behaviors that can be attached to game entities. Within each `<Component>`, individual properties are defined using `<Var>` tags.

*   **`<Schema>`:** The root element, containing a `hash` attribute that likely identifies this specific schema definition.
*   **`<Component>`:** Represents a specific game component. It has a `component_name` attribute that clearly identifies its purpose (e.g., `AIAttackComponent`, `AIComponent`, `MaterialSeaSpawnerComponent`).
*   **`<Var>`:** Defines a single variable or property within a component. Key attributes include:
    *   `name`: The name of the variable (e.g., `use_probability`, `min_distance`, `material`).
    *   `size`: The size of the data in bytes.
    *   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` for strings, `class ceng::math::CVector2<int>` for 2D vectors).

The structure is hierarchical, with `<Component>` tags containing multiple `<Var>` tags, outlining the configurable parameters for that component.

## Key Patterns

Several patterns emerge from the sampled data:

*   **Component-Based Design:** The game uses a component-based architecture, where entities are composed of various functional components. This file defines the structure of these components.
*   **AI and Behavior Definitions:** A significant portion of the schema appears dedicated to defining AI behaviors, particularly attack patterns (`AIAttackComponent`, `AIComponent`). This includes parameters for range, timing, projectile properties, and aiming.
*   **Entity Properties:** Components define properties for various game entities, such as their physical characteristics, interactions, and special abilities (e.g., `ragdoll_fx_custom_entity_apply_only_to_largest_body`, `polymorph_target`).
*   **Material and World Generation:** Components like `MaterialSeaSpawnerComponent` indicate definitions related to how materials are spawned and interact within the game world.
*   **Data Type Specificity:** The `type` attribute in `<Var>` tags is highly specific, often including C++ class names, which suggests the underlying game engine is built with C++. This provides precise information about how data is stored and interpreted.
*   **Naming Conventions:** Variable names are generally descriptive, often using camelCase or snake_case, making it easier to infer their purpose (e.g., `attack_ranged_offset_x`, `teleportation_probability`).

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This snippet from the `AIAttackComponent` defines parameters for an AI's attack capabilities. `use_probability` controls how likely the AI is to use this attack, `min_distance` and `max_distance` define its effective range, `animation_name` specifies the associated animation, and `attack_ranged_entity_file` points to the entity file (likely a projectile or effect) used for ranged attacks.

**2. `MaterialSeaSpawnerComponent` Variables:**

```xml
  <Component component_name="MaterialSeaSpawnerComponent" >

    <Var name="material" size="4" type="int" >
    </Var>

    <Var name="size" size="8" type="class ceng::math::CVector2<int>" >
    </Var>

    <Var name="speed" size="4" type="int" >
    </Var>
```

This section defines parameters for a component responsible for spawning materials, likely in a "sea" or fluid-like manner. `material` specifies the type of material to spawn (represented by an integer ID), `size` defines the dimensions of the spawning area using a 2D integer vector, and `speed` likely controls the rate or velocity of the spawned material.

**3. Polymorph and Status Effect Variables:**

```xml
    <Var name="polymorph_target" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="causing_status_effect" size="4" type="unsigned int" >
    </Var>

    <Var name="caused_by_ingestion_status_effect" size="1" type="bool" >
    </Var>
```

These variables, found within a component (likely related to entity effects or transformations), define more complex behaviors. `polymorph_target` specifies the entity or type to transform into. `causing_status_effect` and `caused_by_ingestion_status_effect` relate to status effects, with the former indicating an effect the entity inflicts and the latter suggesting an effect triggered by ingestion.

## Reference

This file contains 6480 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/48856b5bc6bd8930b95f24a69a069c0c.xml).
---