---
title: ea291057e38b82a8f2f1e889d4057f9e
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/ea291057e38b82a8f2f1e889d4057f9e.xml
---

# ea291057e38b82a8f2f1e889d4057f9e

This XML file, identified by the hash `ea291057e38b82a8f2f1e889d4057f9e`, defines the schema for various game components and their properties within Noita. It acts as a blueprint, dictating the structure and types of data that can be used to configure game entities, behaviors, and attributes. Essentially, it's a data dictionary that the game engine uses to understand and load the properties of different game elements, such as enemies, spells, or environmental objects. This schema file is crucial for game development and modding, as it outlines the available parameters for customization.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute. Inside each `<Component>`, there are multiple `<Var>` elements, each defining a specific variable or property associated with that component.

Each `<Var>` element has the following attributes:
*   `name`: The name of the variable.
*   `size`: The size of the variable in bytes.
*   `type`: The data type of the variable (e.g., `int`, `float`, `bool`, `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`, `class std::vector<int,class std::allocator<int> >`).

The `<Var>` elements themselves are empty, indicating that their values are defined elsewhere, likely in other data files that reference these schemas.

## Key Patterns

*   **Component-Based Architecture:** The file clearly follows a component-based design, where different functionalities are encapsulated within named components (e.g., `AIAttackComponent`, `AIComponent`, `CellEaterComponent`).
*   **Variable Definitions:** Each component is described by a list of its constituent variables, specifying their names, sizes, and data types. This provides a structured way to define the properties of each component.
*   **Data Type Variety:** A range of data types are used, including primitive types like integers (`int`), floating-point numbers (`float`), and booleans (`bool`), as well as more complex C++ types like strings (`class std::basic_string...`) and vectors (`class std::vector...`).
*   **Naming Conventions:** Variable names are descriptive, often indicating their purpose (e.g., `use_probability`, `min_distance`, `animation_name`, `teleportation_radius_min`).
*   **Size Specification:** The `size` attribute suggests that these schemas might be used for low-level data serialization or memory layout definitions.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`:**
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      </Component>
    ```
    This component likely defines the parameters for an AI's attack behavior. It includes variables for attack probability, range, animation, and the entity file used for ranged attacks.

2.  **`CellEaterComponent`:**
    ```xml
    <Component component_name="CellEaterComponent" >
      <Var name="radius" size="4" type="float" >
      </Var>
      <Var name="eat_probability" size="4" type="int" >
      </Var>
      <Var name="ignored_material" size="4" type="int" >
      </Var>
      <Var name="materials" size="12" type="class std::vector<int,class std::allocator<int> >" >
      </Var>
    </Component>
    ```
    This component seems to govern entities that can "eat" or consume certain materials. It specifies the radius of consumption, probability, materials to ignore, and a list of materials it can consume.

3.  **`PhysicsShapeComponent`:**
    ```xml
    <Component component_name="PhysicsShapeComponent" >
      <Var name="recreate" size="1" type="bool" >
      </Var>
      <Var name="is_circle" size="1" type="bool" >
      </Var>
      <Var name="friction" size="4" type="float" >
      </Var>
      <Var name="local_position_x" size="4" type="float" >
      </Var>
    </Component>
    ```
    This component defines the physical properties of an entity's shape. It includes flags for shape type (circle, box, etc.), physical properties like friction, and positional offsets.

## Reference

This file contains 6276 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/ea291057e38b82a8f2f1e889d4057f9e.xml).

---