---
title: 8c17f56a35cb61e9351e97009346b595
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/8c17f56a35cb61e9351e97009346b595.xml
---

# 8c17f56a35cb61e9351e97009346b595

This XML file defines the schema for various game components in Noita. It acts as a blueprint, outlining the structure and types of data that can be associated with different game entities and systems. Essentially, it describes the properties and configurations that can be set for elements like AI behaviors, physical interactions, visual effects, and more. This schema is crucial for the game's engine to correctly interpret and utilize the data associated with these components, enabling the complex behaviors and interactions observed in Noita.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct type of game component. Within each `<Component>`, there are `<Var>` elements that define individual properties or variables associated with that component.

*   **`<Schema>`:** The root element, containing a `hash` attribute.
*   **`<Component>`:** Represents a specific game component. It has a `component_name` attribute that identifies the type of component (e.g., `AIAttackComponent`, `CellEaterComponent`).
*   **`<Var>`:** Defines a variable or property within a component. Each `<Var>` element has the following attributes:
    *   `name`: The name of the variable (e.g., `use_probability`, `radius`).
    *   `size`: The size of the variable in bytes.
    *   `type`: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class std::vector<int,class std::allocator<int> >` (a vector of integers).

The structure is hierarchical: the schema contains components, and components contain variables.

## Key Patterns

*   **Component-Based Design:** The file clearly follows a component-based architecture, where different functionalities are encapsulated into distinct components. This allows for modularity and reusability of game logic.
*   **Variable Definitions:** Each variable is meticulously defined with its name, size, and type, providing a clear contract for how data should be structured.
*   **Data Type Variety:** The schema supports a range of data types, from simple booleans and integers to strings and vectors, allowing for complex configurations.
*   **Naming Conventions:** Component and variable names are generally descriptive, hinting at their purpose (e.g., `attack_ranged_offset_x`, `eat_probability`).
*   **Enum Usage:** Some variables, like `ragdoll_fx` in `DamageNearbyEntitiesComponent`, suggest the use of enumerations (`enum RAGDOLL_FX::Enum`) for predefined sets of values.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`:**
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
    </Component>
    ```
    This component defines parameters related to an AI's attack capabilities. It includes variables for attack probability, range, animation names, and the entity file to be used for ranged attacks.

2.  **`CellEaterComponent`:**
    ```xml
    <Component component_name="CellEaterComponent" >
      <Var name="radius" size="4" type="float" >
      </Var>
      <Var name="eat_probability" size="4" type="int" >
      </Var>
      <Var name="materials" size="12" type="class std::vector<int,class std::allocator<int> >" >
      </Var>
    </Component>
    ```
    This component likely governs entities that consume or "eat" surrounding cells or materials. It specifies the radius of consumption, the probability of eating, and a list of materials that can be eaten.

3.  **`DamageNearbyEntitiesComponent`:**
    ```xml
    <Component component_name="DamageNearbyEntitiesComponent" >
      <Var name="radius" size="4" type="float" >
      </Var>
      <Var name="damage_min" size="4" type="float" >
      </Var>
      <Var name="damage_description" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="target_tag" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
    </Component>
    ```
    This component defines how an entity can damage other entities within a certain radius. It includes parameters for the damage range, a description of the damage, and a tag to identify potential targets.

## Reference

This file contains 6432 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/8c17f56a35cb61e9351e97009346b595.xml).

---