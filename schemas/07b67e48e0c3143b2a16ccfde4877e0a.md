---
title: 07b67e48e0c3143b2a16ccfde4877e0a
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/07b67e48e0c3143b2a16ccfde4877e0a.xml
---

# 07b67e48e0c3143b2a16ccfde4877e0a

This XML file, identified by the hash `07b67e48e0c3143b2a16ccfde4877e0a`, defines the schema for various game components in Noita. It acts as a blueprint, outlining the structure and data types for different functionalities that can be attached to game entities. These components dictate behaviors, properties, and interactions of everything from enemies and player characters to environmental elements and special effects. Understanding this schema is crucial for comprehending how game objects are constructed and how their attributes are defined.

## File Structure

The file is structured as an XML document. The root element is `<Schema>`, which contains multiple `<Component>` elements. Each `<Component>` element represents a distinct type of game component and has a `component_name` attribute that uniquely identifies it.

Inside each `<Component>`, there are `<Var>` elements. These `<Var>` elements define the individual properties or variables that make up that component. Each `<Var>` has the following attributes:

*   **`name`**: The name of the variable.
*   **`size`**: The size of the variable in bytes.
*   **`type`**: The data type of the variable. This can include primitive types like `int`, `float`, `bool`, and more complex C++ types like `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >` (which represents a string) or `class std::vector<...>` (which represents a dynamic array).

The structure is hierarchical: `<Schema>` contains `<Component>`s, and `<Component>`s contain `<Var>`s.

## Key Patterns

*   **Component-Based Architecture**: The file clearly demonstrates a component-based design. Each `<Component>` encapsulates a specific set of functionalities or data.
*   **Variable Definitions**: The `<Var>` tags consistently define the properties of each component, specifying their names, sizes, and data types.
*   **String Representation**: C++ string types are represented using a verbose `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`. This often indicates the underlying C++ implementation.
*   **Enum Types**: Some variables, like `effect` in `GameEffectComponent`, are defined as `enum` types, suggesting a predefined set of possible values.
*   **AI Components**: A significant portion of the schema appears to be dedicated to Artificial Intelligence (`AIComponent`, `AIAttackComponent`, `AdvancedFishAIComponent`, `AnimalAIComponent`), defining parameters for movement, attacks, and states.
*   **Visual/Rendering Components**: Components like `PixelSpriteComponent` define visual aspects, including image files, anchors, and material properties.
*   **Game Mechanics Components**: Components like `AltarComponent` and `GameAreaEffectComponent` define specific game mechanics and their associated parameters.

## Sample Entries

Here are a few representative examples from the sampled content:

1.  **`AIAttackComponent`**:
    ```xml
    <Component component_name="AIAttackComponent" >
      <Var name="use_probability" size="4" type="int" >
      </Var>
      <Var name="min_distance" size="4" type="float" >
      </Var>
      <Var name="max_distance" size="4" type="float" >
      </Var>
      <Var name="angular_range_deg" size="4" type="float" >
      </Var>
      <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="attack_ranged_entity_count_min" size="4" type="int" >
      </Var>
    </Component>
    ```
    This component defines parameters for an AI's attack capabilities. It includes variables for attack probability, range (`min_distance`, `max_distance`), aiming (`angular_range_deg`), associated animations (`animation_name`), and details about ranged attacks such as the projectile entity file (`attack_ranged_entity_file`) and the number of projectiles to spawn (`attack_ranged_entity_count_min`).

2.  **`AltarComponent`**:
    ```xml
    <Component component_name="AltarComponent" >
      <Var name="recognized_entity_tags" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="good_fx_material" size="4" type="int" >
      </Var>
      <Var name="uses_remaining" size="4" type="int" >
      </Var>
    </Component>
    ```
    This component likely defines the behavior of altars in the game. It specifies which entity tags are recognized (`recognized_entity_tags`), the visual effects associated with different altar states (e.g., `good_fx_material`), and how many times the altar can be used (`uses_remaining`).

3.  **`PixelSpriteComponent`**:
    ```xml
    <Component component_name="PixelSpriteComponent" >
      <Var name="image_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="anchor_x" size="4" type="int" >
      </Var>
      <Var name="anchor_y" size="4" type="int" >
      </Var>
      <Var name="material" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
      </Var>
      <Var name="diggable" size="1" type="bool" >
      </Var>
    </Component>
    ```
    This component is responsible for rendering pixel-based sprites. It defines the `image_file` to be used, the sprite's anchor point (`anchor_x`, `anchor_y`), the material it's made of (`material`), and whether it's diggable (`diggable`).

## Reference

This file contains 6428 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/07b67e48e0c3143b2a16ccfde4877e0a.xml).
---