---
title: 2a1e5d743406bb2d100375d3f8e305e3
category: schemas
source: https://github.com/NathanSnail/noitadata/tree/main/data/schemas/2a1e5d743406bb2d100375d3f8e305e3.xml
---

# 2a1e5d743406bb2d100375d3f8e305e3

This XML file defines the structure and properties of various game components within Noita. It acts as a schema, outlining the data fields and their types for different game entities and systems. These definitions are crucial for the game engine to correctly interpret and utilize the data associated with entities like enemies, spells, items, and environmental elements. Essentially, this file describes *what* data each type of component can hold and *how* that data is represented.

## File Structure

The file is structured as a collection of `<Component>` elements, each representing a distinct type of game component. The root element `<Schema>` encloses all these components and has a `hash` attribute, likely a unique identifier for this schema definition.

Each `<Component>` element has a `component_name` attribute that clearly identifies the type of component it defines (e.g., `AIAttackComponent`, `AIComponent`, `HitboxComponent`, `HomingComponent`).

Inside each `<Component>`, there are multiple `<Var>` elements. These `<Var>` elements define individual data variables or properties associated with that component. Each `<Var>` has the following attributes:

*   **`name`**: The name of the variable (e.g., `use_probability`, `min_distance`, `is_player`).
*   **`size`**: The size of the variable in bytes. This often correlates with the `type`.
*   **`type`**: The data type of the variable. Common types observed include:
    *   `int`: Integer numbers.
    *   `float`: Floating-point numbers.
    *   `bool`: Boolean values (true/false).
    *   `class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >`: A string type, often used for file paths or names.
    *   `class ceng::math::CVector2<float>`: A 2D vector of floats, likely for position or direction.

The `<Var>` elements are typically empty, indicating that their values are defined elsewhere in the game's data files, or they are placeholders for runtime values.

## Key Patterns

*   **Component-Based Architecture**: The file strongly suggests a component-based entity system, where game objects are composed of various functional components.
*   **Data Typing and Sizing**: Each variable is explicitly typed and sized, which is essential for efficient data serialization and deserialization by the game engine.
*   **Naming Conventions**: Variable names are descriptive, providing clear hints about their purpose (e.g., `attack_ranged_offset_x`, `bite_damage`, `hitbox_radius`).
*   **AI and Behavior Definitions**: Components like `AIAttackComponent` and `AIComponent` indicate that this schema is used to define the behavior and attributes of AI-controlled entities.
*   **Physical Properties**: Components like `HitboxComponent` define the physical boundaries and interactions of game objects.
*   **Visual/Effect Properties**: Components like `HomingComponent` (though only partially sampled) suggest definitions for visual effects, trails, and rendering properties.

## Sample Entries

Here are a few representative examples from the sampled content:

**1. `AIAttackComponent` Variables:**

```xml
    <Var name="use_probability" size="4" type="int" >
    </Var>

    <Var name="min_distance" size="4" type="float" >
    </Var>

    <Var name="max_distance" size="4" type="float" >
    </Var>

    <Var name="animation_name" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>

    <Var name="attack_ranged_entity_file" size="24" type="class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >" >
    </Var>
```

This snippet shows variables related to an AI's attack capabilities. `use_probability` and `min_distance`/`max_distance` define when and how far an attack can be initiated. `animation_name` likely specifies the animation to play during an attack, and `attack_ranged_entity_file` points to the projectile or entity spawned by a ranged attack.

**2. `AIComponent` Variables (Partial):**

```xml
    <Var name="tail_gravity" size="4" type="float" >
    </Var>

    <Var name="eat_ground" size="1" type="bool" >
    </Var>

    <Var name="bite_damage" size="4" type="float" >
    </Var>
```

This sample illustrates variables that might define more general AI behaviors or specific creature traits. `tail_gravity` could influence how a tail behaves, `eat_ground` suggests an interaction with the environment, and `bite_damage` is a clear indicator of combat-related attributes.

**3. `HitboxComponent` Variables:**

```xml
  <Component component_name="HitboxComponent" >

    <Var name="is_player" size="1" type="bool" >
    </Var>

    <Var name="is_enemy" size="1" type="bool" >
    </Var>

    <Var name="aabb_min_x" size="4" type="float" >
    </Var>

    <Var name="aabb_max_x" size="4" type="float" >
    </Var>

    <Var name="offset" size="8" type="class ceng::math::CVector2<float>" >
    </Var>

    <Var name="damage_multiplier" size="4" type="float" >
    </Var>

  </Component>
```

This component defines the physical collision properties of an entity. `is_player`, `is_enemy`, and `is_item` are flags to categorize the entity. `aabb_min_x`/`max_x` and `aabb_min_y`/`max_y` (implied by the pattern) define the Axis-Aligned Bounding Box for collision detection. `offset` likely adjusts the hitbox position, and `damage_multiplier` affects how much damage the entity takes or deals.

## Reference

This file contains 6804 lines. For complete data, see the [full source](https://github.com/NathanSnail/noitadata/tree/main/data/schemas/2a1e5d743406bb2d100375d3f8e305e3.xml).

---